var We=Object.defineProperty;var c=(n,e)=>We(n,"name",{value:e,configurable:!0});import{createRequire as Je}from"node:module";const qe=Je(import.meta.url);import*as v from"node:path";import i from"typescript";import{createRequire as He}from"node:module";import W from"magic-string";import se from"node:fs/promises";var ie=44,Xe=59,oe="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",ae=new Uint8Array(64),ce=new Uint8Array(128);for(let n=0;n<oe.length;n++){const e=oe.charCodeAt(n);ae[n]=e,ce[e]=n}function B(n,e){let t=0,r=0,s=0;do{const a=n.next();s=ce[a],t|=(s&31)<<r,r+=5}while(s&32);const o=t&1;return t>>>=1,o&&(t=-2147483648|-t),e+t}c(B,"decodeInteger");function $(n,e,t){let r=e-t;r=r<0?-r<<1|1:r<<1;do{let s=r&31;r>>>=5,r>0&&(s|=32),n.write(ae[s])}while(r>0);return e}c($,"encodeInteger");function le(n,e){return n.pos>=e?!1:n.peek()!==ie}c(le,"hasMoreVlq");var ue=1024*16,pe=typeof TextDecoder<"u"?new TextDecoder:typeof Buffer<"u"?{decode(n){return Buffer.from(n.buffer,n.byteOffset,n.byteLength).toString()}}:{decode(n){let e="";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e}},Qe=class{static{c(this,"StringWriter")}constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(ue)}write(n){const{buffer:e}=this;e[this.pos++]=n,this.pos===ue&&(this.out+=pe.decode(e),this.pos=0)}flush(){const{buffer:n,out:e,pos:t}=this;return t>0?e+pe.decode(n.subarray(0,t)):e}},Ye=class{static{c(this,"StringReader")}constructor(n){this.pos=0,this.buffer=n}next(){return this.buffer.charCodeAt(this.pos++)}peek(){return this.buffer.charCodeAt(this.pos)}indexOf(n){const{buffer:e,pos:t}=this,r=e.indexOf(n,t);return r===-1?e.length:r}};function J(n){const{length:e}=n,t=new Ye(n),r=[];let s=0,o=0,a=0,l=0,d=0;do{const m=t.indexOf(";"),u=[];let g=!0,p=0;for(s=0;t.pos<m;){let h;s=B(t,s),s<p&&(g=!1),p=s,le(t,m)?(o=B(t,o),a=B(t,a),l=B(t,l),le(t,m)?(d=B(t,d),h=[s,o,a,l,d]):h=[s,o,a,l]):h=[s],u.push(h),t.pos++}g||Ze(u),r.push(u),t.pos=m+1}while(t.pos<=e);return r}c(J,"decode");function Ze(n){n.sort(et)}c(Ze,"sort");function et(n,e){return n[0]-e[0]}c(et,"sortComparator$1");function fe(n){const e=new Qe;let t=0,r=0,s=0,o=0;for(let a=0;a<n.length;a++){const l=n[a];if(a>0&&e.write(Xe),l.length===0)continue;let d=0;for(let m=0;m<l.length;m++){const u=l[m];m>0&&e.write(ie),d=$(e,u[0],d),u.length!==1&&(t=$(e,u[1],t),r=$(e,u[2],r),s=$(e,u[3],s),u.length!==4&&(o=$(e,u[4],o)))}}return e.flush()}c(fe,"encode");const tt=/^[\w+.-]+:\/\//,nt=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,rt=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function st(n){return tt.test(n)}c(st,"isAbsoluteUrl");function it(n){return n.startsWith("//")}c(it,"isSchemeRelativeUrl");function me(n){return n.startsWith("/")}c(me,"isAbsolutePath");function ot(n){return n.startsWith("file:")}c(ot,"isFileUrl");function de(n){return/^[.?#]/.test(n)}c(de,"isRelative");function G(n){const e=nt.exec(n);return he(e[1],e[2]||"",e[3],e[4]||"",e[5]||"/",e[6]||"",e[7]||"")}c(G,"parseAbsoluteUrl");function at(n){const e=rt.exec(n),t=e[2];return he("file:","",e[1]||"","",me(t)?t:"/"+t,e[3]||"",e[4]||"")}c(at,"parseFileUrl");function he(n,e,t,r,s,o,a){return{scheme:n,user:e,host:t,port:r,path:s,query:o,hash:a,type:7}}c(he,"makeUrl");function ge(n){if(it(n)){const t=G("http:"+n);return t.scheme="",t.type=6,t}if(me(n)){const t=G("http://foo.com"+n);return t.scheme="",t.host="",t.type=5,t}if(ot(n))return at(n);if(st(n))return G(n);const e=G("http://foo.com/"+n);return e.scheme="",e.host="",e.type=n?n.startsWith("?")?3:n.startsWith("#")?2:4:1,e}c(ge,"parseUrl");function ct(n){if(n.endsWith("/.."))return n;const e=n.lastIndexOf("/");return n.slice(0,e+1)}c(ct,"stripPathFilename");function lt(n,e){ye(e,e.type),n.path==="/"?n.path=e.path:n.path=ct(e.path)+n.path}c(lt,"mergePaths");function ye(n,e){const t=e<=4,r=n.path.split("/");let s=1,o=0,a=!1;for(let d=1;d<r.length;d++){const m=r[d];if(!m){a=!0;continue}if(a=!1,m!=="."){if(m===".."){o?(a=!0,o--,s--):t&&(r[s++]=m);continue}r[s++]=m,o++}}let l="";for(let d=1;d<s;d++)l+="/"+r[d];(!l||a&&!l.endsWith("/.."))&&(l+="/"),n.path=l}c(ye,"normalizePath");function ut(n,e){if(!n&&!e)return"";const t=ge(n);let r=t.type;if(e&&r!==7){const o=ge(e),a=o.type;switch(r){case 1:t.hash=o.hash;case 2:t.query=o.query;case 3:case 4:lt(t,o);case 5:t.user=o.user,t.host=o.host,t.port=o.port;case 6:t.scheme=o.scheme}a>r&&(r=a)}ye(t,r);const s=t.query+t.hash;switch(r){case 2:case 3:return s;case 4:{const o=t.path.slice(1);return o?de(e||n)&&!de(o)?"./"+o+s:o+s:s||"."}case 5:return t.path+s;default:return t.scheme+"//"+t.user+t.host+t.port+t.path+s}}c(ut,"resolve");function pt(n){if(!n)return"";const e=n.lastIndexOf("/");return n.slice(0,e+1)}c(pt,"stripFilename");function ft(n,e){const t=pt(n),r=e?e+"/":"";return s=>ut(r+(s||""),t)}c(ft,"resolver");var P=0;function mt(n,e){const t=xe(n,0);if(t===n.length)return n;e||(n=n.slice());for(let r=t;r<n.length;r=xe(n,r+1))n[r]=ht(n[r],e);return n}c(mt,"maybeSort");function xe(n,e){for(let t=e;t<n.length;t++)if(!dt(n[t]))return t;return n.length}c(xe,"nextUnsortedSegmentLine");function dt(n){for(let e=1;e<n.length;e++)if(n[e][P]<n[e-1][P])return!1;return!0}c(dt,"isSorted");function ht(n,e){return e||(n=n.slice()),n.sort(gt)}c(ht,"sortSegments");function gt(n,e){return n[P]-e[P]}c(gt,"sortComparator");var V=!1;function yt(n,e,t,r){for(;t<=r;){const s=t+(r-t>>1),o=n[s][P]-e;if(o===0)return V=!0,s;o<0?t=s+1:r=s-1}return V=!1,t-1}c(yt,"binarySearch");function xt(n,e,t){for(let r=t-1;r>=0&&n[r][P]===e;t=r--);return t}c(xt,"lowerBound");function St(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}c(St,"memoizedState");function vt(n,e,t,r){const{lastKey:s,lastNeedle:o,lastIndex:a}=t;let l=0,d=n.length-1;if(r===s){if(e===o)return V=a!==-1&&n[a][P]===e,a;e>=o?l=a===-1?0:a:d=a}return t.lastKey=r,t.lastNeedle=e,t.lastIndex=yt(n,e,l,d)}c(vt,"memoizedBinarySearch");function Et(n){return typeof n=="string"?JSON.parse(n):n}c(Et,"parse$1");var Se=class{static{c(this,"TraceMap")}constructor(n,e){const t=typeof n=="string";if(!t&&n._decodedMemo)return n;const r=Et(n),{version:s,file:o,names:a,sourceRoot:l,sources:d,sourcesContent:m}=r;this.version=s,this.file=o,this.names=a||[],this.sourceRoot=l,this.sources=d,this.sourcesContent=m,this.ignoreList=r.ignoreList||r.x_google_ignoreList||void 0;const u=ft(e,l);this.resolvedSources=d.map(u);const{mappings:g}=r;if(typeof g=="string")this._encoded=g,this._decoded=void 0;else if(Array.isArray(g))this._encoded=void 0,this._decoded=mt(g,t);else throw r.sections?new Error("TraceMap passed sectioned source map, please use FlattenMap export instead"):new Error(`invalid source map: ${JSON.stringify(r)}`);this._decodedMemo=St(),this._bySources=void 0,this._bySourceMemos=void 0}};function Rn(n){return n}c(Rn,"cast$1");function ve(n){var e;return(e=n)._decoded||(e._decoded=J(n._encoded))}c(ve,"decodedMappings");function Tt(n,e,t){const r=ve(n);if(e>=r.length)return null;const s=r[e],o=Nt(s,n._decodedMemo,e,t);return o===-1?null:s[o]}c(Tt,"traceSegment");function Nt(n,e,t,r,s){let o=vt(n,r,e,t);return V&&(o=xt(n,r,o)),o===-1||o===n.length?-1:o}c(Nt,"traceSegmentInternal");var q=class{static{c(this,"SetArray")}constructor(){this._indexes={__proto__:null},this.array=[]}};function Fn(n){return n}c(Fn,"cast");function Ee(n,e){return n._indexes[e]}c(Ee,"get");function k(n,e){const t=Ee(n,e);if(t!==void 0)return t;const{array:r,_indexes:s}=n,o=r.push(e);return s[e]=o-1}c(k,"put");function Ct(n,e){const t=Ee(n,e);if(t===void 0)return;const{array:r,_indexes:s}=n;for(let o=t+1;o<r.length;o++){const a=r[o];r[o-1]=a,s[a]--}s[e]=void 0,r.pop()}c(Ct,"remove");var Dt=0,wt=1,bt=2,It=3,Mt=4,Te=-1,Ot=class{static{c(this,"GenMapping")}constructor({file:n,sourceRoot:e}={}){this._names=new q,this._sources=new q,this._sourcesContent=[],this._mappings=[],this.file=n,this.sourceRoot=e,this._ignoreList=new q}};function An(n){return n}c(An,"cast2");var Rt=c((n,e,t,r,s,o,a,l)=>Pt(!0,n,e,t,r,s,o,a),"maybeAddSegment");function Ft(n,e,t){const{_sources:r,_sourcesContent:s}=n,o=k(r,e);s[o]=t}c(Ft,"setSourceContent");function At(n,e,t=!0){const{_sources:r,_sourcesContent:s,_ignoreList:o}=n,a=k(r,e);a===s.length&&(s[a]=null),t?k(o,a):Ct(o,a)}c(At,"setIgnore");function Ne(n){const{_mappings:e,_sources:t,_sourcesContent:r,_names:s,_ignoreList:o}=n;return Bt(e),{version:3,file:n.file||void 0,names:s.array,sourceRoot:n.sourceRoot||void 0,sources:t.array,sourcesContent:r,mappings:e,ignoreList:o.array}}c(Ne,"toDecodedMap");function _t(n){const e=Ne(n);return Object.assign({},e,{mappings:fe(e.mappings)})}c(_t,"toEncodedMap");function Pt(n,e,t,r,s,o,a,l,d){const{_mappings:m,_sources:u,_sourcesContent:g,_names:p}=e,h=Lt(m,t),x=Ut(h,r);if(!s)return $t(h,x)?void 0:Ce(h,x,[r]);const S=k(u,s),E=l?k(p,l):Te;if(S===g.length&&(g[S]=null),!kt(h,x,S,o,a,E))return Ce(h,x,l?[r,S,o,a,E]:[r,S,o,a])}c(Pt,"addSegmentInternal");function Lt(n,e){for(let t=n.length;t<=e;t++)n[t]=[];return n[e]}c(Lt,"getIndex");function Ut(n,e){let t=n.length;for(let r=t-1;r>=0;t=r--){const s=n[r];if(e>=s[Dt])break}return t}c(Ut,"getColumnIndex");function Ce(n,e,t){for(let r=n.length;r>e;r--)n[r]=n[r-1];n[e]=t}c(Ce,"insert");function Bt(n){const{length:e}=n;let t=e;for(let r=t-1;r>=0&&!(n[r].length>0);t=r,r--);t<e&&(n.length=t)}c(Bt,"removeEmptyFinalLines");function $t(n,e){return e===0?!0:n[e-1].length===1}c($t,"skipSourceless");function kt(n,e,t,r,s,o){if(e===0)return!1;const a=n[e-1];return a.length===1?!1:t===a[wt]&&r===a[bt]&&s===a[It]&&o===(a.length===5?a[Mt]:Te)}c(kt,"skipSource");var De=we("",-1,-1,"",null,!1),jt=[];function we(n,e,t,r,s,o){return{source:n,line:e,column:t,name:r,content:s,ignore:o}}c(we,"SegmentObject");function be(n,e,t,r,s){return{map:n,sources:e,source:t,content:r,ignore:s}}c(be,"Source");function Ie(n,e){return be(n,e,"",null,!1)}c(Ie,"MapSource");function Kt(n,e,t){return be(null,jt,n,e,t)}c(Kt,"OriginalSource");function zt(n){const e=new Ot({file:n.map.file}),{sources:t,map:r}=n,s=r.names,o=ve(r);for(let a=0;a<o.length;a++){const l=o[a];for(let d=0;d<l.length;d++){const m=l[d],u=m[0];let g=De;if(m.length!==1){const y=t[m[1]];if(g=Me(y,m[2],m[3],m.length===5?s[m[4]]:""),g==null)continue}const{column:p,line:h,name:x,content:S,source:E,ignore:f}=g;Rt(e,a,u,E,h,p,x),E&&S!=null&&Ft(e,E,S),f&&At(e,E,!0)}}return e}c(zt,"traceMappings");function Me(n,e,t,r){if(!n.map)return we(n.source,e,t,r,n.content,n.ignore);const s=Tt(n.map,e,t);return s==null?null:s.length===1?De:Me(n.sources[s[1]],s[2],s[3],s.length===5?n.map.names[s[4]]:r)}c(Me,"originalPositionFor");function Gt(n){return Array.isArray(n)?n:[n]}c(Gt,"asArray");function Vt(n,e){const t=Gt(n).map(o=>new Se(o,"")),r=t.pop();for(let o=0;o<t.length;o++)if(t[o].sources.length>1)throw new Error(`Transformation map ${o} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);let s=Oe(r,e,"",0);for(let o=t.length-1;o>=0;o--)s=Ie(t[o],[s]);return s}c(Vt,"buildSourceMapTree");function Oe(n,e,t,r){const{resolvedSources:s,sourcesContent:o,ignoreList:a}=n,l=r+1,d=s.map((m,u)=>{const g={importer:t,depth:l,source:m||"",content:void 0,ignore:void 0},p=e(g.source,g),{source:h}=g;if(p)return Oe(new Se(p,h),e,h,l);const x=o?o[u]:null,S=a?a.includes(u):!1;return Kt(h,x,S)});return Ie(n,d)}c(Oe,"build");var Wt=class{static{c(this,"SourceMap")}constructor(n,e){const t=e.decodedMappings?Ne(n):_t(n);this.version=t.version,this.file=t.file,this.mappings=t.mappings,this.names=t.names,this.ignoreList=t.ignoreList,this.sourceRoot=t.sourceRoot,this.sources=t.sources,e.excludeContent||(this.sourcesContent=t.sourcesContent)}toString(){return JSON.stringify(this)}};function Jt(n,e,t){const r={excludeContent:!1,decodedMappings:!1},s=Vt(n,e);return new Wt(zt(s),r)}c(Jt,"remapping");function qt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}c(qt,"getDefaultExportFromCjs");var H={},Re;function Ht(){return Re||(Re=1,(function(n){Object.defineProperty(n,"commentRegex",{get:c(function(){return/^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg},"getCommentRegex")}),Object.defineProperty(n,"mapFileCommentRegex",{get:c(function(){return/(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg},"getMapFileCommentRegex")});var e;typeof Buffer<"u"?typeof Buffer.from=="function"?e=t:e=r:e=s;function t(p){return Buffer.from(p,"base64").toString()}c(t,"decodeBase64WithBufferFrom");function r(p){if(typeof value=="number")throw new TypeError("The value to decode must not be of type number.");return new Buffer(p,"base64").toString()}c(r,"decodeBase64WithNewBuffer");function s(p){return decodeURIComponent(escape(atob(p)))}c(s,"decodeBase64WithAtob");function o(p){return p.split(",").pop()}c(o,"stripComment");function a(p,h){var x=n.mapFileCommentRegex.exec(p),S=x[1]||x[2];try{var p=h(S);return p!=null&&typeof p.catch=="function"?p.catch(E):p}catch(f){E(f)}function E(f){throw new Error("An error occurred while trying to read the map file at "+S+`
`+f.stack)}c(E,"throwError")}c(a,"readFromFileMap");function l(p,h){h=h||{},h.hasComment&&(p=o(p)),h.encoding==="base64"?p=e(p):h.encoding==="uri"&&(p=decodeURIComponent(p)),(h.isJSON||h.encoding)&&(p=JSON.parse(p)),this.sourcemap=p}c(l,"Converter"),l.prototype.toJSON=function(p){return JSON.stringify(this.sourcemap,null,p)},typeof Buffer<"u"?typeof Buffer.from=="function"?l.prototype.toBase64=d:l.prototype.toBase64=m:l.prototype.toBase64=u;function d(){var p=this.toJSON();return Buffer.from(p,"utf8").toString("base64")}c(d,"encodeBase64WithBufferFrom");function m(){var p=this.toJSON();if(typeof p=="number")throw new TypeError("The json to encode must not be of type number.");return new Buffer(p,"utf8").toString("base64")}c(m,"encodeBase64WithNewBuffer");function u(){var p=this.toJSON();return btoa(unescape(encodeURIComponent(p)))}c(u,"encodeBase64WithBtoa"),l.prototype.toURI=function(){var p=this.toJSON();return encodeURIComponent(p)},l.prototype.toComment=function(p){var h,x,S;return p!=null&&p.encoding==="uri"?(h="",x=this.toURI()):(h=";base64",x=this.toBase64()),S="sourceMappingURL=data:application/json;charset=utf-8"+h+","+x,p!=null&&p.multiline?"/*# "+S+" */":"//# "+S},l.prototype.toObject=function(){return JSON.parse(this.toJSON())},l.prototype.addProperty=function(p,h){if(this.sourcemap.hasOwnProperty(p))throw new Error('property "'+p+'" already exists on the sourcemap, use set property instead');return this.setProperty(p,h)},l.prototype.setProperty=function(p,h){return this.sourcemap[p]=h,this},l.prototype.getProperty=function(p){return this.sourcemap[p]},n.fromObject=function(p){return new l(p)},n.fromJSON=function(p){return new l(p,{isJSON:!0})},n.fromURI=function(p){return new l(p,{encoding:"uri"})},n.fromBase64=function(p){return new l(p,{encoding:"base64"})},n.fromComment=function(p){var h,x;return p=p.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),h=n.commentRegex.exec(p),x=h&&h[4]||"uri",new l(p,{encoding:x,hasComment:!0})};function g(p){return new l(p,{isJSON:!0})}c(g,"makeConverter"),n.fromMapFileComment=function(p,h){if(typeof h=="string")throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var x=a(p,h);return x!=null&&typeof x.then=="function"?x.then(g):g(x)},n.fromSource=function(p){var h=p.match(n.commentRegex);return h?n.fromComment(h.pop()):null},n.fromMapFileSource=function(p,h){if(typeof h=="string")throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var x=p.match(n.mapFileCommentRegex);return x?n.fromMapFileComment(x.pop(),h):null},n.removeComments=function(p){return p.replace(n.commentRegex,"")},n.removeMapFileComments=function(p){return p.replace(n.mapFileCommentRegex,"")},n.generateMapFileComment=function(p,h){var x="sourceMappingURL="+p;return h&&h.multiline?"/*# "+x+" */":"//# "+x}})(H)),H}c(Ht,"requireConvertSourceMap");var Xt=Ht(),Fe=qt(Xt);function Qt(n){return{...n,compilerOptions:n.compilerOptions??{},respectExternal:n.respectExternal??!1,includeExternal:n.includeExternal??[],sourcemap:n.sourcemap??!1}}c(Qt,"resolveDefaultOptions");const L=/\.d\.(c|m)?tsx?$/,X=/\.json$/,Ae=/((\.d)?\.(c|m)?(t|j)sx?|\.json)$/;function Q(n){return n.replace(Ae,"")}c(Q,"trimExtension");function _e(n){return n.replace(Ae,".d.ts")}c(_e,"getDeclarationId");function j(n,e){return i.createSourceFile(n,e,i.ScriptTarget.Latest,!0)}c(j,"parse");const Y={getCurrentDirectory:c(()=>i.sys.getCurrentDirectory(),"getCurrentDirectory"),getNewLine:c(()=>i.sys.newLine,"getNewLine"),getCanonicalFileName:i.sys.useCaseSensitiveFileNames?n=>n:n=>n.toLowerCase()},Yt={declaration:!0,noEmit:!1,emitDeclarationOnly:!0,noEmitOnError:!0,checkJs:!1,declarationMap:!1,skipLibCheck:!0,preserveSymlinks:!0,target:i.ScriptTarget.ESNext,resolveJsonModule:!0},K=new Map,U=c((...n)=>process.env.DTS_LOG_CACHE?console.log("[cache]",...n):null,"logCache");function Pe([n,e],t){for(U(n),K.set(n,t);n!==e&&n!==v.dirname(n);){if(n=v.dirname(n),U("up",n),K.has(n))return U("has",n);K.set(n,t)}}c(Pe,"cacheConfig");function Z(n,e,t,r){const s={...Yt,declarationMap:r??!1,...e};let o=v.dirname(n),a=[];const l=t||o;if(K.has(l))U("HIT",l);else{U("miss",l);const g=t?v.resolve(process.cwd(),t):i.findConfigFile(o,i.sys.fileExists);if(!g)return{dtsFiles:a,dirName:o,compilerOptions:s};const p=o;o=v.dirname(g);const{config:h,error:x}=i.readConfigFile(g,i.sys.readFile);if(x)return console.error(i.formatDiagnostic(x,Y)),{dtsFiles:a,dirName:o,compilerOptions:s};U("tsconfig",h);const S=i.parseJsonConfigFileContent(h,i.sys,o);Pe(t?[t,t]:[p,o],S)}const{fileNames:d,options:m,errors:u}=K.get(l);return a=d.filter(g=>L.test(g)),u.length?(console.error(i.formatDiagnostics(u,Y)),{dtsFiles:a,dirName:o,compilerOptions:s}):{dtsFiles:a,dirName:o,compilerOptions:{...m,...s}}}c(Z,"getCompilerOptions");function Zt(n,e,t,r){const{dtsFiles:s,compilerOptions:o}=Z(n,e,t,r);return i.createProgram([n].concat(Array.from(s)),o,i.createCompilerHost(o,!0))}c(Zt,"createProgram$1");function en(n,e,t,r){const s=[],o=new Set;let a=[],l="",d={};for(let m of n){if(L.test(m))continue;m=v.resolve(m);const u=Z(m,e,t,r);if(u.dtsFiles.forEach(o.add,o),!a.length){a.push(m),{dirName:l,compilerOptions:d}=u;continue}if(u.dirName===l)a.push(m);else{const g=i.createCompilerHost(d,!0),p=i.createProgram(a.concat(Array.from(o)),d,g);s.push(p),a=[m],{dirName:l,compilerOptions:d}=u}}if(a.length){const m=i.createCompilerHost(d,!0),u=i.createProgram(a.concat(Array.from(o)),d,m);s.push(u)}return s}c(en,"createPrograms");function tn(){let n;try{return{codeFrameColumns:n}=qe("@babel/code-frame"),n}catch{try{return{codeFrameColumns:n}=He(import.meta.url)("@babel/code-frame"),n}catch{}}}c(tn,"getCodeFrame");function nn(n){const e=n.getSourceFile(),t=e.getLineAndCharacterOfPosition(n.getStart()),r=e.getLineAndCharacterOfPosition(n.getEnd());return{start:{line:t.line+1,column:t.character+1},end:{line:r.line+1,column:r.character+1}}}c(nn,"getLocation");function rn(n){const e=tn(),r=n.getSourceFile().getFullText(),s=nn(n);return e?`
`+e(r,s,{highlightCode:!0}):`
${s.start.line}:${s.start.column}: \`${n.getFullText().trim()}\``}c(rn,"frameNode");class D extends Error{static{c(this,"UnsupportedSyntaxError")}constructor(e,t="Syntax not yet supported"){super(`${t}
${rn(e)}`)}}class sn{static{c(this,"NamespaceFixer")}constructor(e){this.sourceFile=e}findNamespaces(){const e=[],t={};for(const r of this.sourceFile.statements){const s={start:r.getStart(),end:r.getEnd()};if(i.isEmptyStatement(r)){e.unshift({name:"",exports:[],location:s});continue}if((i.isImportDeclaration(r)||i.isExportDeclaration(r))&&r.moduleSpecifier&&i.isStringLiteral(r.moduleSpecifier)){const{text:u}=r.moduleSpecifier;if(u.startsWith(".")&&(u.endsWith(".d.ts")||u.endsWith(".d.cts")||u.endsWith(".d.mts"))){const g=r.moduleSpecifier.getStart()+1,p=r.moduleSpecifier.getEnd()-1;e.unshift({name:"",exports:[],location:{start:g,end:p},textBeforeCodeAfter:u.replace(/\.d\.ts$/,".js").replace(/\.d\.cts$/,".cjs").replace(/\.d\.mts$/,".mjs")})}}if(i.isModuleDeclaration(r)&&r.body&&i.isModuleBlock(r.body)){for(const u of r.body.statements)if(i.isExportDeclaration(u)&&u.exportClause){if(i.isNamespaceExport(u.exportClause))continue;for(const g of u.exportClause.elements)g.propertyName&&g.propertyName.getText()==g.name.getText()&&e.unshift({name:"",exports:[],location:{start:g.propertyName.getEnd(),end:g.name.getEnd()}})}}if(i.isClassDeclaration(r)?t[r.name.getText()]={type:"class",generics:r.typeParameters}:i.isFunctionDeclaration(r)?t[r.name.getText()]={type:"function"}:i.isInterfaceDeclaration(r)?t[r.name.getText()]={type:"interface",generics:r.typeParameters}:i.isTypeAliasDeclaration(r)?t[r.name.getText()]={type:"type",generics:r.typeParameters}:i.isModuleDeclaration(r)&&i.isIdentifier(r.name)?t[r.name.getText()]={type:"namespace"}:i.isEnumDeclaration(r)&&(t[r.name.getText()]={type:"enum"}),!i.isVariableStatement(r))continue;const{declarations:o}=r.declarationList;if(o.length!==1)continue;const a=o[0],l=a.name.getText();if(!a.initializer||!i.isCallExpression(a.initializer)){t[l]={type:"var"};continue}const d=a.initializer.arguments[0];if(!a.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze")||!i.isObjectLiteralExpression(d))continue;const m=[];for(const u of d.properties){if(!i.isPropertyAssignment(u)||!(i.isIdentifier(u.name)||i.isStringLiteral(u.name))||u.name.text!=="__proto__"&&!i.isIdentifier(u.initializer))throw new D(u,"Expected a property assignment");u.name.text!=="__proto__"&&m.push({exportedName:u.name.text,localName:u.initializer.getText()})}e.unshift({name:l,exports:m,location:s})}return{namespaces:e,itemTypes:t}}fix(){let e=this.sourceFile.getFullText();const{namespaces:t,itemTypes:r}=this.findNamespaces();for(const s of t){const o=e.slice(s.location.end);e=e.slice(0,s.location.start);for(const{exportedName:a,localName:l}of s.exports)if(a===l){const{type:d,generics:m}=r[l]||{};if(d==="interface"||d==="type"){const u=Le(m);e+=`type ${s.name}_${a}${u.in} = ${l}${u.out};
`}else if(d==="enum"||d==="class"){const u=Le(m);e+=`type ${s.name}_${a}${u.in} = ${l}${u.out};
`,e+=`declare const ${s.name}_${a}: typeof ${l};
`}else d==="namespace"?e+=`import ${s.name}_${a} = ${l};
`:e+=`declare const ${s.name}_${a}: typeof ${l};
`}if(s.name){e+=`declare namespace ${s.name} {
`,e+=`  export {
`;for(const{exportedName:a,localName:l}of s.exports)a===l?e+=`    ${s.name}_${a} as ${a},
`:e+=`    ${l} as ${a},
`;e+=`  };
`,e+="}"}e+=s.textBeforeCodeAfter??"",e+=o}return e}}function Le(n){return!n||!n.length?{in:"",out:""}:{in:`<${n.map(e=>e.getText()).join(", ")}>`,out:`<${n.map(e=>e.name.getText()).join(", ")}>`}}c(Le,"renderTypeParams");let Ue=1;function on(n){return w({type:"Program",sourceType:"module",body:[]},{start:n.getFullStart(),end:n.getEnd()})}c(on,"createProgram");function an(n){const e={type:"Identifier",name:String(Ue++)};return{ident:e,expr:{type:"AssignmentPattern",left:e,right:n}}}c(an,"createReference");function I(n){return w({type:"Identifier",name:n.getText()},n)}c(I,"createIdentifier");function cn(n){const e=w({type:"FunctionExpression",id:null,params:[],body:{type:"BlockStatement",body:[]}},n),t=w({type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:String(Ue++)},arguments:[e],optional:!1}},n);return{fn:e,iife:t}}c(cn,"createIIFE");function ln(){const n={type:"ArrayExpression",elements:[]};return{expr:n,stmt:{type:"ReturnStatement",argument:n}}}c(ln,"createReturn");function un(n,e){return w({type:"FunctionDeclaration",id:w({type:"Identifier",name:i.idText(n)},n),params:[],body:{type:"BlockStatement",body:[]}},e)}c(un,"createDeclaration");function A(n){if(i.isLiteralExpression(n))return{type:"Literal",value:n.text};if(i.isPropertyAccessExpression(n)){if(i.isPrivateIdentifier(n.name))throw new D(n.name);return w({type:"MemberExpression",computed:!1,optional:!1,object:A(n.expression),property:A(n.name)},{start:n.expression.getStart(),end:n.name.getEnd()})}if(i.isObjectLiteralExpression(n))return w({type:"ObjectExpression",properties:n.properties.map(e=>{if(i.isPropertyAssignment(e))return w({type:"Property",key:i.isIdentifier(e.name)?I(e.name):A(e.name),value:A(e.initializer),kind:"init",method:!1,shorthand:!1,computed:i.isComputedPropertyName(e.name)},e);if(i.isShorthandPropertyAssignment(e))return w({type:"Property",key:I(e.name),value:I(e.name),kind:"init",method:!1,shorthand:!0,computed:!1},e);throw new D(e,"Unsupported property type in object literal")})},n);if(i.isArrayLiteralExpression(n))return w({type:"ArrayExpression",elements:n.elements.map(e=>{if(i.isExpression(e))return A(e);throw new D(e,"Unsupported element type in array literal")})},n);if(i.isIdentifier(n))return I(n);if(n.kind==i.SyntaxKind.NullKeyword)return{type:"Literal",value:null};throw new D(n)}c(A,"convertExpression");function w(n,e){const t="start"in e?e:{start:e.getStart(),end:e.getEnd()};return Object.assign(n,t)}c(w,"withStartEnd");function z(n,e){return(i.getCombinedModifierFlags(n)&e)===e}c(z,"matchesModifier");class pn{static{c(this,"LanguageService")}constructor(e){this.fileName="index.d.ts";const t={getCompilationSettings:c(()=>({noEmit:!0,noResolve:!0,skipLibCheck:!0,declaration:!1,checkJs:!1,declarationMap:!1,target:i.ScriptTarget.ESNext}),"getCompilationSettings"),getScriptFileNames:c(()=>[this.fileName],"getScriptFileNames"),getScriptVersion:c(()=>"1","getScriptVersion"),getScriptSnapshot:c(r=>r===this.fileName?i.ScriptSnapshot.fromString(e):void 0,"getScriptSnapshot"),getCurrentDirectory:c(()=>"","getCurrentDirectory"),getDefaultLibFileName:c(()=>"","getDefaultLibFileName"),fileExists:c(r=>r===this.fileName,"fileExists"),readFile:c(r=>r===this.fileName?e:void 0,"readFile")};this.service=i.createLanguageService(t,i.createDocumentRegistry(void 0,""),i.LanguageServiceMode.PartialSemantic)}findReferenceCount(e){const t=this.service.findReferences(this.fileName,e.getStart());return t?.length?t.reduce((r,s)=>r+s.references.length,0):0}}class fn{static{c(this,"TypeOnlyFixer")}constructor(e,t){this.DEBUG=!!process.env.DTS_EXPORTS_FIXER_DEBUG,this.types=new Set,this.values=new Set,this.typeHints=new Map,this.reExportTypeHints=new Map,this.importNodes=[],this.exportNodes=[],this.rawCode=t,this.source=j(e,t),this.code=new W(t)}fix(){return this.analyze(this.source.statements),(this.typeHints.size||this.reExportTypeHints.size)&&(this.service=new pn(this.rawCode),this.importNodes.forEach(e=>this.fixTypeOnlyImport(e))),this.types.size&&this.exportNodes.forEach(e=>this.fixTypeOnlyExport(e)),this.types.size?{magicCode:this.code}:{code:this.rawCode,map:null}}fixTypeOnlyImport(e){let t=!1;const r=[],s=[],o=e.moduleSpecifier.getText(),a=e.importClause.name,l=e.importClause.namedBindings;if(a){const d=a.text;this.isTypeOnly(d)?this.isUselessImport(a)?t=!0:r.push(`import type ${d} from ${o};`):s.push(`import ${d} from ${o};`)}if(l&&i.isNamespaceImport(l)){const d=l.name.text;this.isTypeOnly(d)?this.isUselessImport(l.name)?t=!0:r.push(`import type * as ${d} from ${o};`):s.push(`import * as ${d} from ${o};`)}if(l&&i.isNamedImports(l)){const d=[],m=[];for(const u of l.elements)this.isTypeOnly(u.name.text)?this.isUselessImport(u.name)?t=!0:d.push(u.getText()):m.push(u.getText());d.length&&r.push(`import type { ${d.join(", ")} } from ${o};`),m.length&&s.push(`import { ${m.join(", ")} } from ${o};`)}(r.length||t)&&this.code.overwrite(e.getStart(),e.getEnd(),[...s,...r].join(`
${Be(e)}`))}fixTypeOnlyExport(e){const t=[],r=[],s=e.moduleSpecifier?.getText();if(i.isNamespaceExport(e.exportClause)){const o=e.exportClause.name.text;this.isReExportTypeOnly(o)?t.push(`export type * as ${o} from ${s};`):r.push(`export * as ${o} from ${s};`)}if(i.isNamedExports(e.exportClause)){const o=[],a=[];for(const l of e.exportClause.elements){const d=l.propertyName?.text||l.name.text;(e.moduleSpecifier?this.isReExportTypeOnly(l.name.text):this.isTypeOnly(d))?o.push(l.getText()):a.push(l.getText())}o.length&&t.push(`export type { ${o.join(", ")} }${s?` from ${s}`:""};`),a.length&&r.push(`export { ${a.join(", ")} }${s?` from ${s}`:""};`)}t.length&&this.code.overwrite(e.getStart(),e.getEnd(),[...r,...t].join(`
${Be(e)}`))}analyze(e){for(const t of e){if(this.DEBUG&&console.log(t.getText(),t.kind),i.isImportDeclaration(t)&&t.importClause){this.importNodes.push(t);continue}if(i.isExportDeclaration(t)&&t.exportClause){this.exportNodes.push(t);continue}if(i.isInterfaceDeclaration(t)){this.DEBUG&&console.log(`${t.name.getFullText()} is a type`),this.types.add(t.name.text);continue}if(i.isTypeAliasDeclaration(t)){const r=t.name.text;this.DEBUG&&console.log(`${t.name.getFullText()} is a type`),this.types.add(r);continue}if(i.isEnumDeclaration(t)||i.isFunctionDeclaration(t)||i.isClassDeclaration(t)||i.isVariableStatement(t)){if(i.isVariableStatement(t))for(const r of t.declarationList.declarations)i.isIdentifier(r.name)&&(this.DEBUG&&console.log(`${r.name.getFullText()} is a value (from var statement)`),this.values.add(r.name.text));else t.name&&(this.DEBUG&&console.log(`${t.name.getFullText()} is a value (from declaration)`),this.values.add(t.name.text));continue}if(i.isModuleBlock(t)){this.analyze(t.statements);continue}if(i.isModuleDeclaration(t)){t.name&&i.isIdentifier(t.name)&&(this.DEBUG&&console.log(`${t.name.getFullText()} is a value (from module declaration)`),this.values.add(t.name.text)),this.analyze(t.getChildren());continue}this.DEBUG&&console.log("unhandled statement",t.getFullText(),t.kind)}}isUselessImport(e){const t=this.service.findReferenceCount(e),r=this.typeHints.get(e.text);return r&&r+1>=t}isTypeOnly(e){return this.typeHints.has(e)||this.types.has(e)&&!this.values.has(e)}isReExportTypeOnly(e){return this.reExportTypeHints.has(e)}}function Be(n){const e=n.getFullText().match(/^(?:\n*)([ ]*)/);return" ".repeat(e?.[1]?.length||0)}c(Be,"getNodeIndent");function $e(n,e,t){for(const r of n.statements)ee(e,r),i.isModuleDeclaration(r)&&r.body&&i.isModuleBlock(r.body)&&$e(r.body,e)}c($e,"preProcessNamespaceBody");function mn({sourceFile:n,isEntry:e,isJSON:t}){const r=new W(n.getFullText()),s=!e&&dn(n),o=new Set,a=new Set;let l="";const d=new Map,m=new Map;for(const f of n.statements){if(i.isEmptyStatement(f)){r.remove(f.getStart(),f.getEnd());continue}if(i.isImportDeclaration(f)){if(!f.importClause)continue;f.importClause.name&&o.add(f.importClause.name.text),f.importClause.namedBindings&&(i.isNamespaceImport(f.importClause.namedBindings)?o.add(f.importClause.namedBindings.name.text):f.importClause.namedBindings.elements.forEach(y=>o.add(y.name.text)))}else if(i.isEnumDeclaration(f)||i.isFunctionDeclaration(f)||i.isInterfaceDeclaration(f)||i.isClassDeclaration(f)||i.isTypeAliasDeclaration(f)||i.isModuleDeclaration(f)){if(f.name){const y=f.name.getText();o.add(y),z(f,i.ModifierFlags.ExportDefault)?l=y:(s&&i.isIdentifier(f.name)||z(f,i.ModifierFlags.Export))&&a.add(y),f.flags&i.NodeFlags.GlobalAugmentation||E(y,[te(f),ke(f)])}i.isModuleDeclaration(f)&&(f.body&&i.isModuleBlock(f.body)&&$e(f.body,r),hn(r,f)),ee(r,f)}else if(i.isVariableStatement(f)){const{declarations:y}=f.declarationList,T=z(f,i.ModifierFlags.Export);for(const O of f.declarationList.declarations)if(i.isIdentifier(O.name)){const F=O.name.getText();o.add(F),(s||T)&&a.add(F)}if(ee(r,f),y.length===1){const O=y[0];i.isIdentifier(O.name)&&E(O.name.getText(),[te(f),ke(f)])}else{const O=y.slice(),F=O.shift();E(F.name.getText(),[te(f),F.getEnd()]);for(const _ of O)i.isIdentifier(_.name)&&E(_.name.getText(),[_.getFullStart(),_.getEnd()])}const{flags:C}=f.declarationList,b=`declare ${C&i.NodeFlags.Let?"let":C&i.NodeFlags.Const?"const":"var"} `,M=f.declarationList.getChildren().find(O=>O.kind===i.SyntaxKind.SyntaxList).getChildren();let R=0;for(const O of M)if(O.kind===i.SyntaxKind.CommaToken)R=O.getStart(),r.remove(R,O.getEnd());else if(R){r.appendLeft(R,`;
`);const F=O.getFullStart(),_=r.slice(F,O.getStart()),re=_.length-_.trimStart().length;re?r.overwrite(F,F+re,b):r.appendLeft(F,b)}}}for(const f of n.statements){if(h(f),i.isExportAssignment(f)&&!f.isExportEquals&&(i.isObjectLiteralExpression(f.expression)||i.isArrayLiteralExpression(f.expression))){l||(l=S("export_default")),r.overwrite(f.getStart(),f.expression.getStart(),`declare var ${l} = `);continue}if(z(f,i.ModifierFlags.ExportDefault)&&(i.isFunctionDeclaration(f)||i.isClassDeclaration(f))){if(f.name)continue;l||(l=S("export_default"));const y=f.getChildren(),T=y.findIndex(M=>M.kind===i.SyntaxKind.ClassKeyword||M.kind===i.SyntaxKind.FunctionKeyword),C=y[T],N=y[T+1];if(N.kind>=i.SyntaxKind.FirstPunctuation&&N.kind<=i.SyntaxKind.LastPunctuation){const M=r.slice(C.getEnd(),N.getStart())!=" ";r.appendLeft(N.getStart(),`${M?" ":""}${l}`)}else r.appendRight(C.getEnd(),` ${l}`)}}for(const f of m.values()){const T=f.pop()[0];for(const C of f)r.move(C[0],C[1],T)}l&&r.append(`
export default ${l};
`),a.size&&r.append(`
export { ${[...a].join(", ")} };
`),t&&a.size&&(l=S("export_default"),r.append([`
declare const ${l}: {`,[...a].map(f=>`  ${f}: typeof ${f};`).join(`
`),"};",`export default ${l};
`].join(`
`)));for(const[f,y]of d.entries())r.prepend(`import * as ${y} from "${f}";
`);const u=n.getLineStarts(),g=new Set;for(const f of n.typeReferenceDirectives){g.add(f.fileName);const{line:y}=n.getLineAndCharacterOfPosition(f.pos),T=u[y];let C=n.getLineEndOfPosition(f.pos);r.slice(C,C+1)===`
`&&(C+=1),r.remove(T,C)}const p=new Set;for(const f of n.referencedFiles){p.add(f.fileName);const{line:y}=n.getLineAndCharacterOfPosition(f.pos),T=u[y];let C=n.getLineEndOfPosition(f.pos);r.slice(C,C+1)===`
`&&(C+=1),r.remove(T,C)}return{code:r,typeReferences:g,fileReferences:p};function h(f){if(i.forEachChild(f,h),i.isImportTypeNode(f)){if(!i.isLiteralTypeNode(f.argument)||!i.isStringLiteral(f.argument.literal))throw new D(f,"inline imports should have a literal argument");const y=f.argument.literal.text,T=f.getChildren(),C=T.find(R=>R.kind===i.SyntaxKind.ImportKeyword).getStart();let N=f.getEnd();const b=T.find(R=>R.kind===i.SyntaxKind.DotToken||R.kind===i.SyntaxKind.LessThanToken);b&&(N=b.getStart());const M=x(y);r.overwrite(C,N,M)}}function x(f){let y=d.get(f);return y||(y=S(gn(f)),d.set(f,y)),y}function S(f){let y=f;for(;o.has(y);)y=`_${y}`;return o.add(y),y}function E(f,y){let T=m.get(f);if(!T)T=[y],m.set(f,T);else{const C=T[T.length-1];C[1]===y[0]?C[1]=y[1]:T.push(y)}}}c(mn,"preProcess");function dn(n){let e=!1;for(const t of n.statements){if(i.isExportDeclaration(t)||i.isExportAssignment(t))return!1;(e||i.isImportDeclaration(t)||z(t,i.ModifierFlags.Export))&&(e=!0)}return e}c(dn,"isGlobalModule");function ee(n,e){if(!i.canHaveModifiers(e))return;if(e.parent.kind===i.SyntaxKind.SourceFile){let r=!1;const s=i.isEnumDeclaration(e)||i.isClassDeclaration(e)||i.isFunctionDeclaration(e)||i.isModuleDeclaration(e)||i.isVariableStatement(e);for(const o of e.modifiers??[])switch(o.kind){case i.SyntaxKind.ExportKeyword:case i.SyntaxKind.DefaultKeyword:n.remove(o.getStart(),o.getEnd()+1);break;case i.SyntaxKind.DeclareKeyword:r=!0}s&&!r&&n.appendRight(e.getStart(),"declare ")}}c(ee,"fixModifiers");function hn(n,e){if(!(!e.body||!i.isModuleBlock(e.body))){for(const t of e.body.statements)if(i.isExportDeclaration(t)&&t.exportClause){if(i.isNamespaceExport(t.exportClause))continue;for(const r of t.exportClause.elements)r.propertyName||n.appendLeft(r.name.getEnd(),` as ${r.name.getText()}`)}}}c(hn,"duplicateExports");function gn(n){return n.replace(/[^a-zA-Z0-9_$]/g,()=>"_")}c(gn,"getSafeName");function te(n){const e=n.getFullStart();return e+(je(n,e)?1:0)}c(te,"getStart");function ke(n){const e=n.getEnd();return e+(je(n,e)?1:0)}c(ke,"getEnd");function je(n,e){return n.getSourceFile().getFullText()[e]===`
`}c(je,"newlineAt");const yn=new Set([i.SyntaxKind.LiteralType,i.SyntaxKind.VoidKeyword,i.SyntaxKind.UnknownKeyword,i.SyntaxKind.AnyKeyword,i.SyntaxKind.BooleanKeyword,i.SyntaxKind.NumberKeyword,i.SyntaxKind.StringKeyword,i.SyntaxKind.ObjectKeyword,i.SyntaxKind.NullKeyword,i.SyntaxKind.UndefinedKeyword,i.SyntaxKind.SymbolKeyword,i.SyntaxKind.NeverKeyword,i.SyntaxKind.ThisKeyword,i.SyntaxKind.ThisType,i.SyntaxKind.BigIntKeyword]);class Ke{static{c(this,"DeclarationScope")}constructor({id:e,range:t}){if(this.scopes=[],e)this.declaration=un(e,t);else{const{iife:s,fn:o}=cn(t);this.iife=s,this.declaration=o}const r=ln();this.declaration.body.body.push(r.stmt),this.returnExpr=r.expr}pushScope(){this.scopes.push(new Set)}popScope(e=1){for(let t=0;t<e;t++)this.scopes.pop()}pushTypeVariable(e){const t=e.getText();this.scopes[this.scopes.length-1]?.add(t)}pushReference(e){let t;if(e.type==="Identifier"?t=e.name:e.type==="MemberExpression"&&e.object.type==="Identifier"&&(t=e.object.name),t){for(const o of this.scopes)if(o.has(t))return}if(t==="this")return;const{ident:r,expr:s}=an(e);this.declaration.params.push(s),this.returnExpr.elements.push(r)}pushIdentifierReference(e){this.pushReference(I(e))}convertEntityName(e){return i.isIdentifier(e)?I(e):w({type:"MemberExpression",computed:!1,optional:!1,object:this.convertEntityName(e.left),property:I(e.right)},e)}convertPropertyAccess(e){if(!i.isIdentifier(e.expression)&&!i.isPropertyAccessExpression(e.expression))throw new D(e.expression);if(i.isPrivateIdentifier(e.name))throw new D(e.name);const t=i.isIdentifier(e.expression)?I(e.expression):this.convertPropertyAccess(e.expression);return w({type:"MemberExpression",computed:!1,optional:!1,object:t,property:I(e.name)},e)}convertComputedPropertyName(e){if(!e.name||!i.isComputedPropertyName(e.name))return;const{expression:t}=e.name;if(!(i.isLiteralExpression(t)||i.isPrefixUnaryExpression(t))){if(i.isIdentifier(t))return this.pushReference(I(t));if(i.isPropertyAccessExpression(t))return this.pushReference(this.convertPropertyAccess(t));throw new D(t)}}convertParametersAndType(e){this.convertComputedPropertyName(e);const t=this.convertTypeParameters(e.typeParameters);for(const r of e.parameters)this.convertTypeNode(r.type);this.convertTypeNode(e.type),this.popScope(t)}convertHeritageClauses(e){for(const t of e.heritageClauses||[])for(const r of t.types)this.pushReference(A(r.expression)),this.convertTypeArguments(r)}convertTypeArguments(e){if(e.typeArguments)for(const t of e.typeArguments)this.convertTypeNode(t)}convertMembers(e){for(const t of e){if(i.isPropertyDeclaration(t)||i.isPropertySignature(t)||i.isIndexSignatureDeclaration(t)){i.isPropertyDeclaration(t)&&t.initializer&&i.isPropertyAccessExpression(t.initializer)&&this.pushReference(this.convertPropertyAccess(t.initializer)),this.convertComputedPropertyName(t),this.convertTypeNode(t.type);continue}if(i.isMethodDeclaration(t)||i.isMethodSignature(t)||i.isConstructorDeclaration(t)||i.isConstructSignatureDeclaration(t)||i.isCallSignatureDeclaration(t)||i.isGetAccessorDeclaration(t)||i.isSetAccessorDeclaration(t))this.convertParametersAndType(t);else throw new D(t)}}convertTypeParameters(e){if(!e)return 0;for(const t of e)this.convertTypeNode(t.constraint),this.convertTypeNode(t.default),this.pushScope(),this.pushTypeVariable(t.name);return e.length}convertTypeNode(e){if(e&&!yn.has(e.kind)){if(i.isTypeReferenceNode(e)){this.pushReference(this.convertEntityName(e.typeName)),this.convertTypeArguments(e);return}if(i.isTypeLiteralNode(e)){this.convertMembers(e.members);return}if(i.isArrayTypeNode(e)){this.convertTypeNode(e.elementType);return}if(i.isTupleTypeNode(e)){for(const t of e.elements)this.convertTypeNode(t);return}if(i.isNamedTupleMember(e)||i.isParenthesizedTypeNode(e)||i.isTypeOperatorNode(e)||i.isTypePredicateNode(e)){this.convertTypeNode(e.type);return}if(i.isUnionTypeNode(e)||i.isIntersectionTypeNode(e)){for(const t of e.types)this.convertTypeNode(t);return}if(i.isMappedTypeNode(e)){const{typeParameter:t,type:r,nameType:s}=e;this.convertTypeNode(t.constraint),this.pushScope(),this.pushTypeVariable(t.name),this.convertTypeNode(r),s&&this.convertTypeNode(s),this.popScope();return}if(i.isConditionalTypeNode(e)){this.convertTypeNode(e.checkType),this.pushScope(),this.convertTypeNode(e.extendsType),this.convertTypeNode(e.trueType),this.convertTypeNode(e.falseType),this.popScope();return}if(i.isIndexedAccessTypeNode(e)){this.convertTypeNode(e.objectType),this.convertTypeNode(e.indexType);return}if(i.isFunctionOrConstructorTypeNode(e)){this.convertParametersAndType(e);return}if(i.isTypeQueryNode(e)){const t=this.convertEntityName(e.exprName);this.pushReference(t),this.convertTypeArguments(e);return}if(i.isRestTypeNode(e)){this.convertTypeNode(e.type);return}if(i.isOptionalTypeNode(e)){this.convertTypeNode(e.type);return}if(i.isTemplateLiteralTypeNode(e)){for(const t of e.templateSpans)this.convertTypeNode(t.type);return}if(i.isInferTypeNode(e)){const{typeParameter:t}=e;this.convertTypeNode(t.constraint),this.pushTypeVariable(t.name);return}else throw new D(e)}}convertNamespace(e,t=!1){if(this.pushScope(),t&&e.body&&i.isModuleDeclaration(e.body)){this.convertNamespace(e.body,!0);return}if(!e.body||!i.isModuleBlock(e.body))throw new D(e,'namespace must have a "ModuleBlock" body.');const{statements:r}=e.body;for(const s of r){if(i.isEnumDeclaration(s)||i.isFunctionDeclaration(s)||i.isClassDeclaration(s)||i.isInterfaceDeclaration(s)||i.isTypeAliasDeclaration(s)||i.isModuleDeclaration(s)){if(s.name&&i.isIdentifier(s.name))this.pushTypeVariable(s.name);else throw new D(s,"non-Identifier name not supported");continue}if(i.isVariableStatement(s)){for(const o of s.declarationList.declarations)if(i.isIdentifier(o.name))this.pushTypeVariable(o.name);else throw new D(o,"non-Identifier name not supported");continue}if(i.isImportDeclaration(s)){if(s.importClause&&(s.importClause.name&&this.pushTypeVariable(s.importClause.name),s.importClause.namedBindings))if(i.isNamespaceImport(s.importClause.namedBindings))this.pushTypeVariable(s.importClause.namedBindings.name);else for(const o of s.importClause.namedBindings.elements)this.pushTypeVariable(o.name);continue}if(i.isImportEqualsDeclaration(s)){this.pushTypeVariable(s.name);continue}if(!i.isExportDeclaration(s))throw new D(s,"namespace child (hoisting) not supported yet")}for(const s of r){if(i.isVariableStatement(s)){for(const o of s.declarationList.declarations)o.type&&this.convertTypeNode(o.type);continue}if(i.isFunctionDeclaration(s)){this.convertParametersAndType(s);continue}if(i.isInterfaceDeclaration(s)||i.isClassDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertHeritageClauses(s),this.convertMembers(s.members),this.popScope(o);continue}if(i.isTypeAliasDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertTypeNode(s.type),this.popScope(o);continue}if(i.isModuleDeclaration(s)){this.convertNamespace(s,t);continue}if(!i.isEnumDeclaration(s)&&!i.isImportDeclaration(s)){if(i.isImportEqualsDeclaration(s)){i.isEntityName(s.moduleReference)&&this.pushReference(this.convertEntityName(s.moduleReference));continue}if(i.isExportDeclaration(s)){if(s.exportClause){if(i.isNamespaceExport(s.exportClause))throw new D(s.exportClause);for(const o of s.exportClause.elements){const a=o.propertyName||o.name;this.pushIdentifierReference(a)}}}else throw new D(s,"namespace child (walking) not supported yet")}}this.popScope()}}function xn({sourceFile:n}){return new Sn(n).transform()}c(xn,"convert");class Sn{static{c(this,"Transformer")}constructor(e){this.sourceFile=e,this.declarations=new Map,this.ast=on(e);for(const t of e.statements)this.convertStatement(t)}transform(){return{ast:this.ast}}pushStatement(e){this.ast.body.push(e)}createDeclaration(e,t){const r={start:e.getFullStart(),end:e.getEnd()};if(!t){const l=new Ke({range:r});return this.pushStatement(l.iife),l}const s=t.getText(),o=new Ke({id:t,range:r}),a=this.declarations.get(s);if(a){a.pushIdentifierReference(t),a.declaration.end=r.end;const l=this.ast.body.findIndex(d=>d==a.declaration);for(let d=l+1;d<this.ast.body.length;d++){const m=this.ast.body[d];m.start=m.end=r.end}}else this.pushStatement(o.declaration),this.declarations.set(s,o);return a||o}convertStatement(e){if(i.isEnumDeclaration(e))return this.convertEnumDeclaration(e);if(i.isFunctionDeclaration(e))return this.convertFunctionDeclaration(e);if(i.isInterfaceDeclaration(e)||i.isClassDeclaration(e))return this.convertClassOrInterfaceDeclaration(e);if(i.isTypeAliasDeclaration(e))return this.convertTypeAliasDeclaration(e);if(i.isVariableStatement(e))return this.convertVariableStatement(e);if(i.isExportDeclaration(e)||i.isExportAssignment(e))return this.convertExportDeclaration(e);if(i.isModuleDeclaration(e))return this.convertNamespaceDeclaration(e);if(e.kind===i.SyntaxKind.NamespaceExportDeclaration)return this.removeStatement(e);if(i.isImportDeclaration(e)||i.isImportEqualsDeclaration(e))return this.convertImportDeclaration(e);throw new D(e)}removeStatement(e){this.pushStatement(w({type:"ExpressionStatement",expression:{type:"Literal",value:"pls remove me"}},e))}convertNamespaceDeclaration(e){if(e.flags&i.NodeFlags.GlobalAugmentation||!i.isIdentifier(e.name)){this.createDeclaration(e).convertNamespace(e,!0);return}const r=this.createDeclaration(e,e.name);r.pushIdentifierReference(e.name),r.convertNamespace(e)}convertEnumDeclaration(e){this.createDeclaration(e,e.name).pushIdentifierReference(e.name)}convertFunctionDeclaration(e){if(!e.name)throw new D(e,"FunctionDeclaration should have a name");const t=this.createDeclaration(e,e.name);t.pushIdentifierReference(e.name),t.convertParametersAndType(e)}convertClassOrInterfaceDeclaration(e){if(!e.name)throw new D(e,"ClassDeclaration / InterfaceDeclaration should have a name");const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertHeritageClauses(e),t.convertMembers(e.members),t.popScope(r)}convertTypeAliasDeclaration(e){const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertTypeNode(e.type),t.popScope(r)}convertVariableStatement(e){const{declarations:t}=e.declarationList;if(t.length!==1)throw new D(e,"VariableStatement with more than one declaration not yet supported");for(const r of t){if(!i.isIdentifier(r.name))throw new D(e,"VariableDeclaration must have a name");const s=this.createDeclaration(e,r.name);s.convertTypeNode(r.type),r.initializer&&this.trackExpressionReferences(r.initializer,s)}}trackExpressionReferences(e,t){if(i.isIdentifier(e))t.pushIdentifierReference(e);else if(i.isObjectLiteralExpression(e))for(const r of e.properties)i.isShorthandPropertyAssignment(r)?t.pushIdentifierReference(r.name):i.isPropertyAssignment(r)&&this.trackExpressionReferences(r.initializer,t);else if(i.isArrayLiteralExpression(e))for(const r of e.elements)i.isExpression(r)&&this.trackExpressionReferences(r,t);else i.isPropertyAccessExpression(e)&&this.trackExpressionReferences(e.expression,t)}convertExportDeclaration(e){if(i.isExportAssignment(e)){this.pushStatement(w({type:"ExportDefaultDeclaration",declaration:A(e.expression)},e));return}const t=e.moduleSpecifier?A(e.moduleSpecifier):void 0;if(!e.exportClause)this.pushStatement(w({type:"ExportAllDeclaration",source:t,exported:null,attributes:[]},e));else if(i.isNamespaceExport(e.exportClause))this.pushStatement(w({type:"ExportAllDeclaration",source:t,exported:I(e.exportClause.name),attributes:[]},e));else{const r=[];for(const s of e.exportClause.elements)r.push(this.convertExportSpecifier(s));this.pushStatement(w({type:"ExportNamedDeclaration",declaration:null,specifiers:r,source:t,attributes:[]},e))}}convertImportDeclaration(e){if(i.isImportEqualsDeclaration(e)){if(i.isEntityName(e.moduleReference)){const s=this.createDeclaration(e,e.name);s.pushReference(s.convertEntityName(e.moduleReference));return}if(!i.isExternalModuleReference(e.moduleReference))throw new D(e,"ImportEquals should have a literal source.");this.pushStatement(w({type:"ImportDeclaration",specifiers:[{type:"ImportDefaultSpecifier",local:I(e.name)}],source:A(e.moduleReference.expression),attributes:[]},e));return}const t=A(e.moduleSpecifier),r=e.importClause&&e.importClause.namedBindings?this.convertNamedImportBindings(e.importClause.namedBindings):[];e.importClause&&e.importClause.name&&r.push({type:"ImportDefaultSpecifier",local:I(e.importClause.name)}),this.pushStatement(w({type:"ImportDeclaration",specifiers:r,source:t,attributes:[]},e))}convertNamedImportBindings(e){return i.isNamedImports(e)?e.elements.map(t=>{const r=I(t.name),s=t.propertyName?I(t.propertyName):r;return{type:"ImportSpecifier",local:r,imported:s}}):[{type:"ImportNamespaceSpecifier",local:I(e.name)}]}convertExportSpecifier(e){const t=I(e.name);return{type:"ExportSpecifier",exported:t,local:e.propertyName?I(e.propertyName):t}}}class vn{static{c(this,"RelativeModuleDeclarationFixer")}constructor(e,t,r,s){this.sourcemap=r,this.DEBUG=!!process.env.DTS_EXPORTS_FIXER_DEBUG,this.relativeModuleDeclarations=[],this.source=j(e,t.toString()),this.code=t,this.name=s||"./index"}fix(){this.analyze(this.source.statements);for(const e of this.relativeModuleDeclarations){const t=e.getStart(),r=e.getEnd(),s=e.name.kind===i.SyntaxKind.StringLiteral&&"singleQuote"in e.name&&e.name.singleQuote?"'":'"',o=`declare module ${s}${this.name}${s} ${e.body.getText()}`;this.code.overwrite(t,r,o)}return{code:this.code.toString(),map:this.relativeModuleDeclarations.length&&this.sourcemap?this.code.generateMap():null}}analyze(e){for(const t of e)i.isModuleDeclaration(t)&&t.body&&i.isModuleBlock(t.body)&&/^\.\.?\//.test(t.name.text)&&(this.DEBUG&&console.log(`Found relative module declaration: ${t.name.text} in ${this.source.fileName}`),this.relativeModuleDeclarations.push(t))}}function En(n,e,t){const r=J(n),s=J(e.mappings),o=t.split(`
`),a=[];for(let l=0;l<r.length;l+=1){const d=r[l];if(!d||d.length===0){a.push([]);continue}const m=d.find(y=>y.length>=4);if(!m){a.push(d);continue}const[,u,g]=m;if(u!==0||g===void 0||g<0||g>=s.length){a.push(d);continue}const p=s[g];if(!p||p.length===0){a.push(d);continue}const h=m[0],x=m.length>=4?m[3]:0,S=h-(x??0),E=o[l]||"",f=[];for(const y of p){const T=y[0]+S;T<0||T>E.length||(y.length===5?f.push([T,y[1],y[2],y[3],y[4]]):y.length===4?f.push([T,y[1],y[2],y[3]]):f.push([T]))}f.sort((y,T)=>y[0]-T[0]),a.push(f)}return fe(a)}c(En,"hydrateSourcemap");async function Tn(n){const{fileName:e,originalCode:t,inputMapText:r}=n;if(process.env.DTS_DEBUG_SOURCEMAP&&(console.log("[sourcemap] loadInputSourcemap:",e),console.log("[sourcemap]   inputMapText:",r?"present ("+r.length+" chars)":"undefined")),r)try{const a=JSON.parse(r);return process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap]   parsed pre-loaded map, sources:",a.sources),a}catch{return null}const s=Fe.fromSource(t);if(s)return s.toObject();const o=c(async a=>{const l=a.split(/[?#]/)[0],d=v.resolve(v.dirname(e),l);return se.readFile(d,"utf8")},"readMap");try{const a=await Fe.fromMapFileSource(t,o);if(a)return a.toObject()}catch{}try{const a=await se.readFile(e+".map","utf8");return JSON.parse(a)}catch{return null}}c(Tn,"loadInputSourcemap");const Nn=c(()=>{const n=new Map,e=new Map,t=new Map;return{name:"dts-transform",buildStart(){n.clear(),e.clear(),t.clear()},options({onLog:r,...s}){return{...s,onLog(o,a,l){o==="warn"&&a.code==="CIRCULAR_DEPENDENCY"||(r?r(o,a,l):l(o,a))},treeshake:{moduleSideEffects:"no-external",propertyReadSideEffects:!0,unknownGlobalSideEffects:!1}}},outputOptions(r){return{...r,chunkFileNames:r.chunkFileNames||"[name]-[hash].d.ts",entryFileNames:r.entryFileNames||"[name].d.ts",format:"es",exports:"named",compact:!1,freeze:!0,interop:"esModule",generatedCode:Object.assign({symbols:!1},r.generatedCode),strict:!1}},transform(r,s,o){const a=Q(s),l=this.getModuleIds(),d=Array.from(l).find(S=>Q(S)===a),m=!!(d&&this.getModuleInfo(d)?.isEntry),u=!!(d&&X.test(d));let g=j(s,r);const p=mn({sourceFile:g,isEntry:m,isJSON:u});n.set(g.fileName,p.typeReferences),e.set(g.fileName,p.fileReferences),r=p.code.toString(),g=j(s,r);const h=xn({sourceFile:g});process.env.DTS_DUMP_AST&&(console.log(s),console.log(r),console.log(JSON.stringify(h.ast.body,void 0,2)));const x=p.code.generateMap({hires:!0,source:s});return L.test(s)&&(process.env.DTS_DEBUG_SOURCEMAP&&(console.log("[sourcemap] transform storing:",s),console.log("[sourcemap]   inputMapText:",o?"present ("+o.length+" chars)":"undefined")),t.set(s,{fileName:s,originalCode:r,inputMapText:o})),process.env.DTS_DEBUG_SOURCEMAP&&(console.log("[sourcemap] transform returning map for:",s),console.log("[sourcemap]   map.sources:",x.sources)),{code:r,ast:h.ast,map:x}},renderChunk(r,s,o){const a=j(s.fileName,r),l=new sn(a),d=new Set,m=new Set;for(const x of Object.keys(s.modules)){for(const S of n.get(x.split("\\").join("/"))||[])d.add(S);for(const S of e.get(x.split("\\").join("/"))||[])if(S.startsWith(".")){const E=v.join(v.dirname(x),S),f=o.file&&v.dirname(o.file)||s.facadeModuleId&&v.dirname(s.facadeModuleId)||".";let y=v.relative(f,E).split("\\").join("/");y[0]!=="."&&(y="./"+y),m.add(y)}else m.add(S)}let u=ze(Array.from(m,x=>`/// <reference path="${x}" />`));u+=ze(Array.from(d,x=>`/// <reference types="${x}" />`)),u+=l.fix(),u||(u+=`
export { };`);const p=new fn(s.fileName,u).fix();return new vn(s.fileName,"magicCode"in p&&p.magicCode?p.magicCode:new W(u),!!o.sourcemap,"./"+v.basename(s.fileName,".d.ts")).fix()},async generateBundle(r,s){if(!r.sourcemap)return;const o=new Map,a=Array.from(t.entries()),l=await Promise.all(a.map(async([u,g])=>({fileName:u,inputMap:await Tn(g)}))),d=c(u=>/^[a-z][a-z0-9+.-]*:\/\//i.test(u),"isUrl");for(const{fileName:u,inputMap:g}of l)if(g&&g.sources){const p=v.dirname(u);let h;g.sourceRoot?h=d(g.sourceRoot)?g.sourceRoot:v.resolve(p,g.sourceRoot):h=p;const x=d(h);o.set(u,{version:g.version??3,sources:g.sources.map(S=>{if(S===null)return null;if(d(S))return S;if(x){const E=h.endsWith("/")?h:h+"/";return new URL(S,E).toString()}return v.isAbsolute(S)?S:v.resolve(h,S)}),mappings:g.mappings,names:g.names})}const m=r.dir||(r.file?v.dirname(r.file):process.cwd());for(const u of Object.values(s)){if(u.type!=="chunk"||!u.map)continue;const g=v.join(m,v.dirname(u.fileName)),p=c(N=>d(N)?N:(v.isAbsolute(N)?v.relative(g,N):N).replaceAll("\\","/"),"toRelativeSourcePath"),h=c(N=>N===null?null:p(N),"toRelativeSourcePathOrNull"),x=new Map;process.env.DTS_DEBUG_SOURCEMAP&&(console.log("[sourcemap] generateBundle for chunk:",u.fileName),console.log("[sourcemap]   chunkDir:",g),console.log("[sourcemap]   chunk.map.sources:",u.map.sources),console.log("[sourcemap]   inputSourcemaps keys:",Array.from(o.keys())));for(const N of u.map.sources){if(!N||d(N))continue;const b=v.resolve(g,N);process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap]   checking source:",N,"->",b);let M=o.get(b);if(!M&&b.endsWith(".ts")&&!b.endsWith(".d.ts")){const R=b.replace(/\.([cm]?)ts$/,".d.$1ts");M=o.get(R),process.env.DTS_DEBUG_SOURCEMAP&&M&&console.log("[sourcemap]   FOUND inputMap via .d.ts fallback:",R)}M&&(process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap]   FOUND inputMap for:",b),x.set(b,M))}if(process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap]   sourcesToRemap.size:",x.size),x.size===0){if(delete u.map.sourcesContent,u.map.sources.length===0&&u.facadeModuleId){const N=o.get(u.facadeModuleId);if(N&&N.sources.length>0){const b=N.sources.map(h);u.map.sources=b}}Ge(s,u.fileName,{sources:u.map.sources.map(h),mappings:u.map.mappings,names:u.map.names||[]});continue}const E=u.map.sources.length===1&&x.size===1?Array.from(x.values())[0]:null,f=E&&E.sources.length===1;let y,T,C;if(f&&E)y=E.sources.map(h),T=En(u.map.mappings,E,u.code),C=E.names||[];else{const N=Jt(u.map,b=>{const M=v.resolve(g,b),R=x.get(M);return R||null});y=N.sources.map(h),T=typeof N.mappings=="string"?N.mappings:"",C=N.names||[]}u.map.sources=y,delete u.map.sourcesContent,u.map.mappings=T,u.map.names=C,Ge(s,u.fileName,{sources:y,mappings:T,names:C})}}}},"transform");function ze(n){return n.length?n.join(`
`)+`
`:""}c(ze,"writeBlock");function Ge(n,e,t){const r=`${e}.map`,s=n[r];s&&s.type==="asset"&&(s.source=JSON.stringify({version:3,file:v.basename(e),...t}))}c(Ge,"updateSourcemapAsset");const Cn=/\.([cm]ts|[tj]sx?)$/;function ne({entries:n,programs:e,resolvedOptions:t},r,s){const{compilerOptions:o,tsconfig:a}=t;if(!e.length&&L.test(r))return{code:s};const l=n.includes(r),d=e.find(m=>{if(l)return m.getRootFileNames().includes(r);{const u=m.getSourceFile(r);return u&&m.isSourceFileFromExternalLibrary(u)?!1:!!u}});if(d){const m=d.getSourceFile(r);return{code:m?.getFullText(),source:m,program:d}}else if(i.sys.fileExists(r)){if(e.length>0&&L.test(r)&&(t.includeExternal.length>0||t.respectExternal))return{code:s};const m=Zt(r,o,a,t.sourcemap);e.push(m);const u=m.getSourceFile(r);return{code:u?.getFullText(),source:u,program:m}}else return null}c(ne,"getModule");const Ve=c((n={})=>{const e=Nn(),t={entries:[],programs:[],resolvedOptions:Qt(n)};return{name:"dts",outputOptions:e.outputOptions,renderChunk:e.renderChunk,generateBundle:e.generateBundle,options(r){let{input:s=[]}=r;if(!Array.isArray(s))s=typeof s=="string"?[s]:Object.values(s);else if(s.length>1){r.input={};for(const o of s){let a=Q(o);v.isAbsolute(o)?a=v.basename(a):a=v.normalize(a),r.input[a]=o}}return t.programs=en(Object.values(s),t.resolvedOptions.compilerOptions,t.resolvedOptions.tsconfig,t.resolvedOptions.sourcemap),e.options.call(this,r)},transform(r,s){if(!Cn.test(s)&&!X.test(s))return null;const o=c(m=>{if(m.program){const u=v.dirname(s);m.program.getSourceFiles().map(p=>p.fileName).filter(p=>p.startsWith(u)).forEach(this.addWatchFile)}},"watchFiles"),a=c(()=>{const m=ne(t,s,r);return m?(o(m),e.transform.call(this,m.code,s)):null},"handleDtsFile"),l=c(()=>{const m=_e(s),u=ne(t,m,r);return u?(o(u),e.transform.call(this,u.code,m)):null},"treatTsAsDts"),d=c(()=>{const m=ne(t,s,r);if(!m||!m.source||!m.program)return null;o(m);const u=_e(s);let g,p;const{emitSkipped:h,diagnostics:x}=m.program.emit(m.source,(E,f)=>{process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap] emit callback:",E,"length:",f.length),E.endsWith(".map")?(p=f,process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap]   declarationMapText:",f)):(g=f,process.env.DTS_DEBUG_SOURCEMAP&&console.log("[sourcemap]   declarationText:",f.slice(0,200)))},void 0,!0,void 0,!0);if(h){const E=x.filter(f=>f.category===i.DiagnosticCategory.Error);E.length&&(console.error(i.formatDiagnostics(E,Y)),this.error("Failed to compile. Check the logs above."))}if(!g)return null;const S=g.replace(/\n?\/\/# sourceMappingURL=[^\n]+/,"");return e.transform.call(this,S,u,p)},"generateDts");return L.test(s)?a():X.test(s)?d():l()??d()},resolveId(r,s){if(!s){t.entries.push(v.resolve(r));return}s=s.split("\\").join("/");let o=t.resolvedOptions.compilerOptions;if(t.resolvedOptions.tsconfig){const l=r.startsWith(".")?v.resolve(v.dirname(s),r):r;o=Z(l,t.resolvedOptions.compilerOptions,t.resolvedOptions.tsconfig,t.resolvedOptions.sourcemap).compilerOptions}const{resolvedModule:a}=i.resolveModuleName(r,s,o,i.sys);if(a)return a.isExternalLibraryImport&&a.packageId&&t.resolvedOptions.includeExternal.includes(a.packageId.name)?{id:v.resolve(a.resolvedFileName)}:!t.resolvedOptions.respectExternal&&a.isExternalLibraryImport?{id:r,external:!0}:{id:v.resolve(a.resolvedFileName)}}}},"plugin");export{Ve as default,Ve as dts};
