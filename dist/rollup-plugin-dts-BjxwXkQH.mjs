var Ge=Object.defineProperty;var a=(n,e)=>Ge(n,"name",{value:e,configurable:!0});import{createRequire as We}from"node:module";const qe=We(import.meta.url);import*as v from"node:path";import i from"typescript";import{createRequire as He}from"node:module";import G from"magic-string";import se from"node:fs/promises";var ie=44,Xe=59,oe="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",ae=new Uint8Array(64),ce=new Uint8Array(128);for(let n=0;n<oe.length;n++){const e=oe.charCodeAt(n);ae[n]=e,ce[e]=n}function B(n,e){let t=0,r=0,s=0;do{const c=n.next();s=ce[c],t|=(s&31)<<r,r+=5}while(s&32);const o=t&1;return t>>>=1,o&&(t=-2147483648|-t),e+t}a(B,"decodeInteger");function k(n,e,t){let r=e-t;r=r<0?-r<<1|1:r<<1;do{let s=r&31;r>>>=5,r>0&&(s|=32),n.write(ae[s])}while(r>0);return e}a(k,"encodeInteger");function le(n,e){return n.pos>=e?!1:n.peek()!==ie}a(le,"hasMoreVlq");var ue=1024*16,pe=typeof TextDecoder<"u"?new TextDecoder:typeof Buffer<"u"?{decode(n){return Buffer.from(n.buffer,n.byteOffset,n.byteLength).toString()}}:{decode(n){let e="";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e}},Qe=class{static{a(this,"StringWriter")}constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(ue)}write(n){const{buffer:e}=this;e[this.pos++]=n,this.pos===ue&&(this.out+=pe.decode(e),this.pos=0)}flush(){const{buffer:n,out:e,pos:t}=this;return t>0?e+pe.decode(n.subarray(0,t)):e}},Ye=class{static{a(this,"StringReader")}constructor(n){this.pos=0,this.buffer=n}next(){return this.buffer.charCodeAt(this.pos++)}peek(){return this.buffer.charCodeAt(this.pos)}indexOf(n){const{buffer:e,pos:t}=this,r=e.indexOf(n,t);return r===-1?e.length:r}};function W(n){const{length:e}=n,t=new Ye(n),r=[];let s=0,o=0,c=0,l=0,d=0;do{const m=t.indexOf(";"),u=[];let y=!0,p=0;for(s=0;t.pos<m;){let h;s=B(t,s),s<p&&(y=!1),p=s,le(t,m)?(o=B(t,o),c=B(t,c),l=B(t,l),le(t,m)?(d=B(t,d),h=[s,o,c,l,d]):h=[s,o,c,l]):h=[s],u.push(h),t.pos++}y||Ze(u),r.push(u),t.pos=m+1}while(t.pos<=e);return r}a(W,"decode");function Ze(n){n.sort(et)}a(Ze,"sort");function et(n,e){return n[0]-e[0]}a(et,"sortComparator$1");function fe(n){const e=new Qe;let t=0,r=0,s=0,o=0;for(let c=0;c<n.length;c++){const l=n[c];if(c>0&&e.write(Xe),l.length===0)continue;let d=0;for(let m=0;m<l.length;m++){const u=l[m];m>0&&e.write(ie),d=k(e,u[0],d),u.length!==1&&(t=k(e,u[1],t),r=k(e,u[2],r),s=k(e,u[3],s),u.length!==4&&(o=k(e,u[4],o)))}}return e.flush()}a(fe,"encode");const tt=/^[\w+.-]+:\/\//,nt=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,rt=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function st(n){return tt.test(n)}a(st,"isAbsoluteUrl");function it(n){return n.startsWith("//")}a(it,"isSchemeRelativeUrl");function me(n){return n.startsWith("/")}a(me,"isAbsolutePath");function ot(n){return n.startsWith("file:")}a(ot,"isFileUrl");function de(n){return/^[.?#]/.test(n)}a(de,"isRelative");function V(n){const e=nt.exec(n);return he(e[1],e[2]||"",e[3],e[4]||"",e[5]||"/",e[6]||"",e[7]||"")}a(V,"parseAbsoluteUrl");function at(n){const e=rt.exec(n),t=e[2];return he("file:","",e[1]||"","",me(t)?t:"/"+t,e[3]||"",e[4]||"")}a(at,"parseFileUrl");function he(n,e,t,r,s,o,c){return{scheme:n,user:e,host:t,port:r,path:s,query:o,hash:c,type:7}}a(he,"makeUrl");function ye(n){if(it(n)){const t=V("http:"+n);return t.scheme="",t.type=6,t}if(me(n)){const t=V("http://foo.com"+n);return t.scheme="",t.host="",t.type=5,t}if(ot(n))return at(n);if(st(n))return V(n);const e=V("http://foo.com/"+n);return e.scheme="",e.host="",e.type=n?n.startsWith("?")?3:n.startsWith("#")?2:4:1,e}a(ye,"parseUrl");function ct(n){if(n.endsWith("/.."))return n;const e=n.lastIndexOf("/");return n.slice(0,e+1)}a(ct,"stripPathFilename");function lt(n,e){ge(e,e.type),n.path==="/"?n.path=e.path:n.path=ct(e.path)+n.path}a(lt,"mergePaths");function ge(n,e){const t=e<=4,r=n.path.split("/");let s=1,o=0,c=!1;for(let d=1;d<r.length;d++){const m=r[d];if(!m){c=!0;continue}if(c=!1,m!=="."){if(m===".."){o?(c=!0,o--,s--):t&&(r[s++]=m);continue}r[s++]=m,o++}}let l="";for(let d=1;d<s;d++)l+="/"+r[d];(!l||c&&!l.endsWith("/.."))&&(l+="/"),n.path=l}a(ge,"normalizePath");function ut(n,e){if(!n&&!e)return"";const t=ye(n);let r=t.type;if(e&&r!==7){const o=ye(e),c=o.type;switch(r){case 1:t.hash=o.hash;case 2:t.query=o.query;case 3:case 4:lt(t,o);case 5:t.user=o.user,t.host=o.host,t.port=o.port;case 6:t.scheme=o.scheme}c>r&&(r=c)}ge(t,r);const s=t.query+t.hash;switch(r){case 2:case 3:return s;case 4:{const o=t.path.slice(1);return o?de(e||n)&&!de(o)?"./"+o+s:o+s:s||"."}case 5:return t.path+s;default:return t.scheme+"//"+t.user+t.host+t.port+t.path+s}}a(ut,"resolve");function pt(n){if(!n)return"";const e=n.lastIndexOf("/");return n.slice(0,e+1)}a(pt,"stripFilename");function ft(n,e){const t=pt(n),r=e?e+"/":"";return s=>ut(r+(s||""),t)}a(ft,"resolver");var L=0;function mt(n,e){const t=xe(n,0);if(t===n.length)return n;e||(n=n.slice());for(let r=t;r<n.length;r=xe(n,r+1))n[r]=ht(n[r],e);return n}a(mt,"maybeSort");function xe(n,e){for(let t=e;t<n.length;t++)if(!dt(n[t]))return t;return n.length}a(xe,"nextUnsortedSegmentLine");function dt(n){for(let e=1;e<n.length;e++)if(n[e][L]<n[e-1][L])return!1;return!0}a(dt,"isSorted");function ht(n,e){return e||(n=n.slice()),n.sort(yt)}a(ht,"sortSegments");function yt(n,e){return n[L]-e[L]}a(yt,"sortComparator");var J=!1;function gt(n,e,t,r){for(;t<=r;){const s=t+(r-t>>1),o=n[s][L]-e;if(o===0)return J=!0,s;o<0?t=s+1:r=s-1}return J=!1,t-1}a(gt,"binarySearch");function xt(n,e,t){for(let r=t-1;r>=0&&n[r][L]===e;t=r--);return t}a(xt,"lowerBound");function St(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}a(St,"memoizedState");function vt(n,e,t,r){const{lastKey:s,lastNeedle:o,lastIndex:c}=t;let l=0,d=n.length-1;if(r===s){if(e===o)return J=c!==-1&&n[c][L]===e,c;e>=o?l=c===-1?0:c:d=c}return t.lastKey=r,t.lastNeedle=e,t.lastIndex=gt(n,e,l,d)}a(vt,"memoizedBinarySearch");function Et(n){return typeof n=="string"?JSON.parse(n):n}a(Et,"parse$1");var Se=class{static{a(this,"TraceMap")}constructor(n,e){const t=typeof n=="string";if(!t&&n._decodedMemo)return n;const r=Et(n),{version:s,file:o,names:c,sourceRoot:l,sources:d,sourcesContent:m}=r;this.version=s,this.file=o,this.names=c||[],this.sourceRoot=l,this.sources=d,this.sourcesContent=m,this.ignoreList=r.ignoreList||r.x_google_ignoreList||void 0;const u=ft(e,l);this.resolvedSources=d.map(u);const{mappings:y}=r;if(typeof y=="string")this._encoded=y,this._decoded=void 0;else if(Array.isArray(y))this._encoded=void 0,this._decoded=mt(y,t);else throw r.sections?new Error("TraceMap passed sectioned source map, please use FlattenMap export instead"):new Error(`invalid source map: ${JSON.stringify(r)}`);this._decodedMemo=St(),this._bySources=void 0,this._bySourceMemos=void 0}};function On(n){return n}a(On,"cast$1");function ve(n){var e;return(e=n)._decoded||(e._decoded=W(n._encoded))}a(ve,"decodedMappings");function Nt(n,e,t){const r=ve(n);if(e>=r.length)return null;const s=r[e],o=Tt(s,n._decodedMemo,e,t);return o===-1?null:s[o]}a(Nt,"traceSegment");function Tt(n,e,t,r,s){let o=vt(n,r,e,t);return J&&(o=xt(n,r,o)),o===-1||o===n.length?-1:o}a(Tt,"traceSegmentInternal");var q=class{static{a(this,"SetArray")}constructor(){this._indexes={__proto__:null},this.array=[]}};function Rn(n){return n}a(Rn,"cast");function Ee(n,e){return n._indexes[e]}a(Ee,"get");function j(n,e){const t=Ee(n,e);if(t!==void 0)return t;const{array:r,_indexes:s}=n,o=r.push(e);return s[e]=o-1}a(j,"put");function Ct(n,e){const t=Ee(n,e);if(t===void 0)return;const{array:r,_indexes:s}=n;for(let o=t+1;o<r.length;o++){const c=r[o];r[o-1]=c,s[c]--}s[e]=void 0,r.pop()}a(Ct,"remove");var wt=0,Dt=1,bt=2,It=3,Mt=4,Ne=-1,Ft=class{static{a(this,"GenMapping")}constructor({file:n,sourceRoot:e}={}){this._names=new q,this._sources=new q,this._sourcesContent=[],this._mappings=[],this.file=n,this.sourceRoot=e,this._ignoreList=new q}};function An(n){return n}a(An,"cast2");var Ot=a((n,e,t,r,s,o,c,l)=>Lt(!0,n,e,t,r,s,o,c),"maybeAddSegment");function Rt(n,e,t){const{_sources:r,_sourcesContent:s}=n,o=j(r,e);s[o]=t}a(Rt,"setSourceContent");function At(n,e,t=!0){const{_sources:r,_sourcesContent:s,_ignoreList:o}=n,c=j(r,e);c===s.length&&(s[c]=null),t?j(o,c):Ct(o,c)}a(At,"setIgnore");function Te(n){const{_mappings:e,_sources:t,_sourcesContent:r,_names:s,_ignoreList:o}=n;return Bt(e),{version:3,file:n.file||void 0,names:s.array,sourceRoot:n.sourceRoot||void 0,sources:t.array,sourcesContent:r,mappings:e,ignoreList:o.array}}a(Te,"toDecodedMap");function Pt(n){const e=Te(n);return Object.assign({},e,{mappings:fe(e.mappings)})}a(Pt,"toEncodedMap");function Lt(n,e,t,r,s,o,c,l,d){const{_mappings:m,_sources:u,_sourcesContent:y,_names:p}=e,h=_t(m,t),x=$t(h,r);if(!s)return kt(h,x)?void 0:Ce(h,x,[r]);const S=j(u,s),T=l?j(p,l):Ne;if(S===y.length&&(y[S]=null),!jt(h,x,S,o,c,T))return Ce(h,x,l?[r,S,o,c,T]:[r,S,o,c])}a(Lt,"addSegmentInternal");function _t(n,e){for(let t=n.length;t<=e;t++)n[t]=[];return n[e]}a(_t,"getIndex");function $t(n,e){let t=n.length;for(let r=t-1;r>=0;t=r--){const s=n[r];if(e>=s[wt])break}return t}a($t,"getColumnIndex");function Ce(n,e,t){for(let r=n.length;r>e;r--)n[r]=n[r-1];n[e]=t}a(Ce,"insert");function Bt(n){const{length:e}=n;let t=e;for(let r=t-1;r>=0&&!(n[r].length>0);t=r,r--);t<e&&(n.length=t)}a(Bt,"removeEmptyFinalLines");function kt(n,e){return e===0?!0:n[e-1].length===1}a(kt,"skipSourceless");function jt(n,e,t,r,s,o){if(e===0)return!1;const c=n[e-1];return c.length===1?!1:t===c[Dt]&&r===c[bt]&&s===c[It]&&o===(c.length===5?c[Mt]:Ne)}a(jt,"skipSource");var we=De("",-1,-1,"",null,!1),Ut=[];function De(n,e,t,r,s,o){return{source:n,line:e,column:t,name:r,content:s,ignore:o}}a(De,"SegmentObject");function be(n,e,t,r,s){return{map:n,sources:e,source:t,content:r,ignore:s}}a(be,"Source");function Ie(n,e){return be(n,e,"",null,!1)}a(Ie,"MapSource");function Kt(n,e,t){return be(null,Ut,n,e,t)}a(Kt,"OriginalSource");function zt(n){const e=new Ft({file:n.map.file}),{sources:t,map:r}=n,s=r.names,o=ve(r);for(let c=0;c<o.length;c++){const l=o[c];for(let d=0;d<l.length;d++){const m=l[d],u=m[0];let y=we;if(m.length!==1){const g=t[m[1]];if(y=Me(g,m[2],m[3],m.length===5?s[m[4]]:""),y==null)continue}const{column:p,line:h,name:x,content:S,source:T,ignore:f}=y;Ot(e,c,u,T,h,p,x),T&&S!=null&&Rt(e,T,S),f&&At(e,T,!0)}}return e}a(zt,"traceMappings");function Me(n,e,t,r){if(!n.map)return De(n.source,e,t,r,n.content,n.ignore);const s=Nt(n.map,e,t);return s==null?null:s.length===1?we:Me(n.sources[s[1]],s[2],s[3],s.length===5?n.map.names[s[4]]:r)}a(Me,"originalPositionFor");function Vt(n){return Array.isArray(n)?n:[n]}a(Vt,"asArray");function Jt(n,e){const t=Vt(n).map(o=>new Se(o,"")),r=t.pop();for(let o=0;o<t.length;o++)if(t[o].sources.length>1)throw new Error(`Transformation map ${o} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);let s=Fe(r,e,"",0);for(let o=t.length-1;o>=0;o--)s=Ie(t[o],[s]);return s}a(Jt,"buildSourceMapTree");function Fe(n,e,t,r){const{resolvedSources:s,sourcesContent:o,ignoreList:c}=n,l=r+1,d=s.map((m,u)=>{const y={importer:t,depth:l,source:m||"",content:void 0,ignore:void 0},p=e(y.source,y),{source:h}=y;if(p)return Fe(new Se(p,h),e,h,l);const x=o?o[u]:null,S=c?c.includes(u):!1;return Kt(h,x,S)});return Ie(n,d)}a(Fe,"build");var Gt=class{static{a(this,"SourceMap")}constructor(n,e){const t=e.decodedMappings?Te(n):Pt(n);this.version=t.version,this.file=t.file,this.mappings=t.mappings,this.names=t.names,this.ignoreList=t.ignoreList,this.sourceRoot=t.sourceRoot,this.sources=t.sources,e.excludeContent||(this.sourcesContent=t.sourcesContent)}toString(){return JSON.stringify(this)}};function Wt(n,e,t){const r={excludeContent:!1,decodedMappings:!1},s=Jt(n,e);return new Gt(zt(s),r)}a(Wt,"remapping");function qt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}a(qt,"getDefaultExportFromCjs");var H={},Oe;function Ht(){return Oe||(Oe=1,(function(n){Object.defineProperty(n,"commentRegex",{get:a(function(){return/^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg},"getCommentRegex")}),Object.defineProperty(n,"mapFileCommentRegex",{get:a(function(){return/(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg},"getMapFileCommentRegex")});var e;typeof Buffer<"u"?typeof Buffer.from=="function"?e=t:e=r:e=s;function t(p){return Buffer.from(p,"base64").toString()}a(t,"decodeBase64WithBufferFrom");function r(p){if(typeof value=="number")throw new TypeError("The value to decode must not be of type number.");return new Buffer(p,"base64").toString()}a(r,"decodeBase64WithNewBuffer");function s(p){return decodeURIComponent(escape(atob(p)))}a(s,"decodeBase64WithAtob");function o(p){return p.split(",").pop()}a(o,"stripComment");function c(p,h){var x=n.mapFileCommentRegex.exec(p),S=x[1]||x[2];try{var p=h(S);return p!=null&&typeof p.catch=="function"?p.catch(T):p}catch(f){T(f)}function T(f){throw new Error("An error occurred while trying to read the map file at "+S+`
`+f.stack)}a(T,"throwError")}a(c,"readFromFileMap");function l(p,h){h=h||{},h.hasComment&&(p=o(p)),h.encoding==="base64"?p=e(p):h.encoding==="uri"&&(p=decodeURIComponent(p)),(h.isJSON||h.encoding)&&(p=JSON.parse(p)),this.sourcemap=p}a(l,"Converter"),l.prototype.toJSON=function(p){return JSON.stringify(this.sourcemap,null,p)},typeof Buffer<"u"?typeof Buffer.from=="function"?l.prototype.toBase64=d:l.prototype.toBase64=m:l.prototype.toBase64=u;function d(){var p=this.toJSON();return Buffer.from(p,"utf8").toString("base64")}a(d,"encodeBase64WithBufferFrom");function m(){var p=this.toJSON();if(typeof p=="number")throw new TypeError("The json to encode must not be of type number.");return new Buffer(p,"utf8").toString("base64")}a(m,"encodeBase64WithNewBuffer");function u(){var p=this.toJSON();return btoa(unescape(encodeURIComponent(p)))}a(u,"encodeBase64WithBtoa"),l.prototype.toURI=function(){var p=this.toJSON();return encodeURIComponent(p)},l.prototype.toComment=function(p){var h,x,S;return p!=null&&p.encoding==="uri"?(h="",x=this.toURI()):(h=";base64",x=this.toBase64()),S="sourceMappingURL=data:application/json;charset=utf-8"+h+","+x,p!=null&&p.multiline?"/*# "+S+" */":"//# "+S},l.prototype.toObject=function(){return JSON.parse(this.toJSON())},l.prototype.addProperty=function(p,h){if(this.sourcemap.hasOwnProperty(p))throw new Error('property "'+p+'" already exists on the sourcemap, use set property instead');return this.setProperty(p,h)},l.prototype.setProperty=function(p,h){return this.sourcemap[p]=h,this},l.prototype.getProperty=function(p){return this.sourcemap[p]},n.fromObject=function(p){return new l(p)},n.fromJSON=function(p){return new l(p,{isJSON:!0})},n.fromURI=function(p){return new l(p,{encoding:"uri"})},n.fromBase64=function(p){return new l(p,{encoding:"base64"})},n.fromComment=function(p){var h,x;return p=p.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),h=n.commentRegex.exec(p),x=h&&h[4]||"uri",new l(p,{encoding:x,hasComment:!0})};function y(p){return new l(p,{isJSON:!0})}a(y,"makeConverter"),n.fromMapFileComment=function(p,h){if(typeof h=="string")throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var x=c(p,h);return x!=null&&typeof x.then=="function"?x.then(y):y(x)},n.fromSource=function(p){var h=p.match(n.commentRegex);return h?n.fromComment(h.pop()):null},n.fromMapFileSource=function(p,h){if(typeof h=="string")throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var x=p.match(n.mapFileCommentRegex);return x?n.fromMapFileComment(x.pop(),h):null},n.removeComments=function(p){return p.replace(n.commentRegex,"")},n.removeMapFileComments=function(p){return p.replace(n.mapFileCommentRegex,"")},n.generateMapFileComment=function(p,h){var x="sourceMappingURL="+p;return h&&h.multiline?"/*# "+x+" */":"//# "+x}})(H)),H}a(Ht,"requireConvertSourceMap");var Xt=Ht(),Re=qt(Xt);function Qt(n){return{...n,compilerOptions:n.compilerOptions??{},respectExternal:n.respectExternal??!1,includeExternal:n.includeExternal??[]}}a(Qt,"resolveDefaultOptions");const _=/\.d\.(c|m)?tsx?$/,X=/\.json$/,Ae=/((\.d)?\.(c|m)?(t|j)sx?|\.json)$/;function Q(n){return n.replace(Ae,"")}a(Q,"trimExtension");function Pe(n){return n.replace(Ae,".d.ts")}a(Pe,"getDeclarationId");function U(n,e){return i.createSourceFile(n,e,i.ScriptTarget.Latest,!0)}a(U,"parse");const Y={getCurrentDirectory:a(()=>i.sys.getCurrentDirectory(),"getCurrentDirectory"),getNewLine:a(()=>i.sys.newLine,"getNewLine"),getCanonicalFileName:i.sys.useCaseSensitiveFileNames?n=>n:n=>n.toLowerCase()},Yt={declaration:!0,noEmit:!1,emitDeclarationOnly:!0,noEmitOnError:!0,checkJs:!1,declarationMap:!1,skipLibCheck:!0,preserveSymlinks:!0,target:i.ScriptTarget.ESNext,resolveJsonModule:!0},K=new Map,$=a((...n)=>process.env.DTS_LOG_CACHE?console.log("[cache]",...n):null,"logCache");function Le([n,e],t){for($(n),K.set(n,t);n!==e&&n!==v.dirname(n);){if(n=v.dirname(n),$("up",n),K.has(n))return $("has",n);K.set(n,t)}}a(Le,"cacheConfig");function Z(n,e,t){const r={...Yt,...e};let s=v.dirname(n),o=[];const c=t||s;if(K.has(c))$("HIT",c);else{$("miss",c);const u=t?v.resolve(process.cwd(),t):i.findConfigFile(s,i.sys.fileExists);if(!u)return{dtsFiles:o,dirName:s,compilerOptions:r};const y=s;s=v.dirname(u);const{config:p,error:h}=i.readConfigFile(u,i.sys.readFile);if(h)return console.error(i.formatDiagnostic(h,Y)),{dtsFiles:o,dirName:s,compilerOptions:r};$("tsconfig",p);const x=i.parseJsonConfigFileContent(p,i.sys,s);Le(t?[t,t]:[y,s],x)}const{fileNames:l,options:d,errors:m}=K.get(c);return o=l.filter(u=>_.test(u)),m.length?(console.error(i.formatDiagnostics(m,Y)),{dtsFiles:o,dirName:s,compilerOptions:r}):{dtsFiles:o,dirName:s,compilerOptions:{...d,...r}}}a(Z,"getCompilerOptions");function Zt(n,e,t){const{dtsFiles:r,compilerOptions:s}=Z(n,e,t);return i.createProgram([n].concat(Array.from(r)),s,i.createCompilerHost(s,!0))}a(Zt,"createProgram$1");function en(n,e,t){const r=[],s=new Set;let o=[],c="",l={};for(let d of n){if(_.test(d))continue;d=v.resolve(d);const m=Z(d,e,t);if(m.dtsFiles.forEach(s.add,s),!o.length){o.push(d),{dirName:c,compilerOptions:l}=m;continue}if(m.dirName===c)o.push(d);else{const u=i.createCompilerHost(l,!0),y=i.createProgram(o.concat(Array.from(s)),l,u);r.push(y),o=[d],{dirName:c,compilerOptions:l}=m}}if(o.length){const d=i.createCompilerHost(l,!0),m=i.createProgram(o.concat(Array.from(s)),l,d);r.push(m)}return r}a(en,"createPrograms");function tn(){let n;try{return{codeFrameColumns:n}=qe("@babel/code-frame"),n}catch{try{return{codeFrameColumns:n}=He(import.meta.url)("@babel/code-frame"),n}catch{}}}a(tn,"getCodeFrame");function nn(n){const e=n.getSourceFile(),t=e.getLineAndCharacterOfPosition(n.getStart()),r=e.getLineAndCharacterOfPosition(n.getEnd());return{start:{line:t.line+1,column:t.character+1},end:{line:r.line+1,column:r.character+1}}}a(nn,"getLocation");function rn(n){const e=tn(),r=n.getSourceFile().getFullText(),s=nn(n);return e?`
`+e(r,s,{highlightCode:!0}):`
${s.start.line}:${s.start.column}: \`${n.getFullText().trim()}\``}a(rn,"frameNode");class w extends Error{static{a(this,"UnsupportedSyntaxError")}constructor(e,t="Syntax not yet supported"){super(`${t}
${rn(e)}`)}}class sn{static{a(this,"NamespaceFixer")}constructor(e){this.sourceFile=e}findNamespaces(){const e=[],t={};for(const r of this.sourceFile.statements){const s={start:r.getStart(),end:r.getEnd()};if(i.isEmptyStatement(r)){e.unshift({name:"",exports:[],location:s});continue}if((i.isImportDeclaration(r)||i.isExportDeclaration(r))&&r.moduleSpecifier&&i.isStringLiteral(r.moduleSpecifier)){const{text:u}=r.moduleSpecifier;if(u.startsWith(".")&&(u.endsWith(".d.ts")||u.endsWith(".d.cts")||u.endsWith(".d.mts"))){const y=r.moduleSpecifier.getStart()+1,p=r.moduleSpecifier.getEnd()-1;e.unshift({name:"",exports:[],location:{start:y,end:p},textBeforeCodeAfter:u.replace(/\.d\.ts$/,".js").replace(/\.d\.cts$/,".cjs").replace(/\.d\.mts$/,".mjs")})}}if(i.isModuleDeclaration(r)&&r.body&&i.isModuleBlock(r.body)){for(const u of r.body.statements)if(i.isExportDeclaration(u)&&u.exportClause){if(i.isNamespaceExport(u.exportClause))continue;for(const y of u.exportClause.elements)y.propertyName&&y.propertyName.getText()==y.name.getText()&&e.unshift({name:"",exports:[],location:{start:y.propertyName.getEnd(),end:y.name.getEnd()}})}}if(i.isClassDeclaration(r)?t[r.name.getText()]={type:"class",generics:r.typeParameters}:i.isFunctionDeclaration(r)?t[r.name.getText()]={type:"function"}:i.isInterfaceDeclaration(r)?t[r.name.getText()]={type:"interface",generics:r.typeParameters}:i.isTypeAliasDeclaration(r)?t[r.name.getText()]={type:"type",generics:r.typeParameters}:i.isModuleDeclaration(r)&&i.isIdentifier(r.name)?t[r.name.getText()]={type:"namespace"}:i.isEnumDeclaration(r)&&(t[r.name.getText()]={type:"enum"}),!i.isVariableStatement(r))continue;const{declarations:o}=r.declarationList;if(o.length!==1)continue;const c=o[0],l=c.name.getText();if(!c.initializer||!i.isCallExpression(c.initializer)){t[l]={type:"var"};continue}const d=c.initializer.arguments[0];if(!c.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze")||!i.isObjectLiteralExpression(d))continue;const m=[];for(const u of d.properties){if(!i.isPropertyAssignment(u)||!(i.isIdentifier(u.name)||i.isStringLiteral(u.name))||u.name.text!=="__proto__"&&!i.isIdentifier(u.initializer))throw new w(u,"Expected a property assignment");u.name.text!=="__proto__"&&m.push({exportedName:u.name.text,localName:u.initializer.getText()})}e.unshift({name:l,exports:m,location:s})}return{namespaces:e,itemTypes:t}}fix(){let e=this.sourceFile.getFullText();const{namespaces:t,itemTypes:r}=this.findNamespaces();for(const s of t){const o=e.slice(s.location.end);e=e.slice(0,s.location.start);for(const{exportedName:c,localName:l}of s.exports)if(c===l){const{type:d,generics:m}=r[l]||{};if(d==="interface"||d==="type"){const u=_e(m);e+=`type ${s.name}_${c}${u.in} = ${l}${u.out};
`}else if(d==="enum"||d==="class"){const u=_e(m);e+=`type ${s.name}_${c}${u.in} = ${l}${u.out};
`,e+=`declare const ${s.name}_${c}: typeof ${l};
`}else d==="namespace"?e+=`import ${s.name}_${c} = ${l};
`:e+=`declare const ${s.name}_${c}: typeof ${l};
`}if(s.name){e+=`declare namespace ${s.name} {
`,e+=`  export {
`;for(const{exportedName:c,localName:l}of s.exports)c===l?e+=`    ${s.name}_${c} as ${c},
`:e+=`    ${l} as ${c},
`;e+=`  };
`,e+="}"}e+=s.textBeforeCodeAfter??"",e+=o}return e}}function _e(n){return!n||!n.length?{in:"",out:""}:{in:`<${n.map(e=>e.getText()).join(", ")}>`,out:`<${n.map(e=>e.name.getText()).join(", ")}>`}}a(_e,"renderTypeParams");let $e=1;function on(n){return D({type:"Program",sourceType:"module",body:[]},{start:n.getFullStart(),end:n.getEnd()})}a(on,"createProgram");function an(n){const e={type:"Identifier",name:String($e++)};return{ident:e,expr:{type:"AssignmentPattern",left:e,right:n}}}a(an,"createReference");function b(n){return D({type:"Identifier",name:n.getText()},n)}a(b,"createIdentifier");function cn(n){const e=D({type:"FunctionExpression",id:null,params:[],body:{type:"BlockStatement",body:[]}},n),t=D({type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:String($e++)},arguments:[e],optional:!1}},n);return{fn:e,iife:t}}a(cn,"createIIFE");function ln(){const n={type:"ArrayExpression",elements:[]};return{expr:n,stmt:{type:"ReturnStatement",argument:n}}}a(ln,"createReturn");function un(n,e){return D({type:"FunctionDeclaration",id:D({type:"Identifier",name:i.idText(n)},n),params:[],body:{type:"BlockStatement",body:[]}},e)}a(un,"createDeclaration");function A(n){if(i.isLiteralExpression(n))return{type:"Literal",value:n.text};if(i.isPropertyAccessExpression(n)){if(i.isPrivateIdentifier(n.name))throw new w(n.name);return D({type:"MemberExpression",computed:!1,optional:!1,object:A(n.expression),property:A(n.name)},{start:n.expression.getStart(),end:n.name.getEnd()})}if(i.isObjectLiteralExpression(n))return D({type:"ObjectExpression",properties:n.properties.map(e=>{if(i.isPropertyAssignment(e))return D({type:"Property",key:i.isIdentifier(e.name)?b(e.name):A(e.name),value:A(e.initializer),kind:"init",method:!1,shorthand:!1,computed:i.isComputedPropertyName(e.name)},e);if(i.isShorthandPropertyAssignment(e))return D({type:"Property",key:b(e.name),value:b(e.name),kind:"init",method:!1,shorthand:!0,computed:!1},e);throw new w(e,"Unsupported property type in object literal")})},n);if(i.isArrayLiteralExpression(n))return D({type:"ArrayExpression",elements:n.elements.map(e=>{if(i.isExpression(e))return A(e);throw new w(e,"Unsupported element type in array literal")})},n);if(i.isIdentifier(n))return b(n);if(n.kind==i.SyntaxKind.NullKeyword)return{type:"Literal",value:null};throw new w(n)}a(A,"convertExpression");function D(n,e){const t="start"in e?e:{start:e.getStart(),end:e.getEnd()};return Object.assign(n,t)}a(D,"withStartEnd");function z(n,e){return(i.getCombinedModifierFlags(n)&e)===e}a(z,"matchesModifier");class pn{static{a(this,"LanguageService")}constructor(e){this.fileName="index.d.ts";const t={getCompilationSettings:a(()=>({noEmit:!0,noResolve:!0,skipLibCheck:!0,declaration:!1,checkJs:!1,declarationMap:!1,target:i.ScriptTarget.ESNext}),"getCompilationSettings"),getScriptFileNames:a(()=>[this.fileName],"getScriptFileNames"),getScriptVersion:a(()=>"1","getScriptVersion"),getScriptSnapshot:a(r=>r===this.fileName?i.ScriptSnapshot.fromString(e):void 0,"getScriptSnapshot"),getCurrentDirectory:a(()=>"","getCurrentDirectory"),getDefaultLibFileName:a(()=>"","getDefaultLibFileName"),fileExists:a(r=>r===this.fileName,"fileExists"),readFile:a(r=>r===this.fileName?e:void 0,"readFile")};this.service=i.createLanguageService(t,i.createDocumentRegistry(void 0,""),i.LanguageServiceMode.PartialSemantic)}findReferenceCount(e){const t=this.service.findReferences(this.fileName,e.getStart());return t?.length?t.reduce((r,s)=>r+s.references.length,0):0}}class fn{static{a(this,"TypeOnlyFixer")}constructor(e,t){this.DEBUG=!!process.env.DTS_EXPORTS_FIXER_DEBUG,this.types=new Set,this.values=new Set,this.typeHints=new Map,this.reExportTypeHints=new Map,this.importNodes=[],this.exportNodes=[],this.rawCode=t,this.source=U(e,t),this.code=new G(t)}fix(){return this.analyze(this.source.statements),(this.typeHints.size||this.reExportTypeHints.size)&&(this.service=new pn(this.rawCode),this.importNodes.forEach(e=>this.fixTypeOnlyImport(e))),this.types.size&&this.exportNodes.forEach(e=>this.fixTypeOnlyExport(e)),this.types.size?{magicCode:this.code}:{code:this.rawCode,map:null}}fixTypeOnlyImport(e){let t=!1;const r=[],s=[],o=e.moduleSpecifier.getText(),c=e.importClause.name,l=e.importClause.namedBindings;if(c){const d=c.text;this.isTypeOnly(d)?this.isUselessImport(c)?t=!0:r.push(`import type ${d} from ${o};`):s.push(`import ${d} from ${o};`)}if(l&&i.isNamespaceImport(l)){const d=l.name.text;this.isTypeOnly(d)?this.isUselessImport(l.name)?t=!0:r.push(`import type * as ${d} from ${o};`):s.push(`import * as ${d} from ${o};`)}if(l&&i.isNamedImports(l)){const d=[],m=[];for(const u of l.elements)this.isTypeOnly(u.name.text)?this.isUselessImport(u.name)?t=!0:d.push(u.getText()):m.push(u.getText());d.length&&r.push(`import type { ${d.join(", ")} } from ${o};`),m.length&&s.push(`import { ${m.join(", ")} } from ${o};`)}(r.length||t)&&this.code.overwrite(e.getStart(),e.getEnd(),[...s,...r].join(`
${Be(e)}`))}fixTypeOnlyExport(e){const t=[],r=[],s=e.moduleSpecifier?.getText();if(i.isNamespaceExport(e.exportClause)){const o=e.exportClause.name.text;this.isReExportTypeOnly(o)?t.push(`export type * as ${o} from ${s};`):r.push(`export * as ${o} from ${s};`)}if(i.isNamedExports(e.exportClause)){const o=[],c=[];for(const l of e.exportClause.elements){const d=l.propertyName?.text||l.name.text;(e.moduleSpecifier?this.isReExportTypeOnly(l.name.text):this.isTypeOnly(d))?o.push(l.getText()):c.push(l.getText())}o.length&&t.push(`export type { ${o.join(", ")} }${s?` from ${s}`:""};`),c.length&&r.push(`export { ${c.join(", ")} }${s?` from ${s}`:""};`)}t.length&&this.code.overwrite(e.getStart(),e.getEnd(),[...r,...t].join(`
${Be(e)}`))}analyze(e){for(const t of e){if(this.DEBUG&&console.log(t.getText(),t.kind),i.isImportDeclaration(t)&&t.importClause){this.importNodes.push(t);continue}if(i.isExportDeclaration(t)&&t.exportClause){this.exportNodes.push(t);continue}if(i.isInterfaceDeclaration(t)){this.DEBUG&&console.log(`${t.name.getFullText()} is a type`),this.types.add(t.name.text);continue}if(i.isTypeAliasDeclaration(t)){const r=t.name.text;this.DEBUG&&console.log(`${t.name.getFullText()} is a type`),this.types.add(r);continue}if(i.isEnumDeclaration(t)||i.isFunctionDeclaration(t)||i.isClassDeclaration(t)||i.isVariableStatement(t)){if(i.isVariableStatement(t))for(const r of t.declarationList.declarations)i.isIdentifier(r.name)&&(this.DEBUG&&console.log(`${r.name.getFullText()} is a value (from var statement)`),this.values.add(r.name.text));else t.name&&(this.DEBUG&&console.log(`${t.name.getFullText()} is a value (from declaration)`),this.values.add(t.name.text));continue}if(i.isModuleBlock(t)){this.analyze(t.statements);continue}if(i.isModuleDeclaration(t)){t.name&&i.isIdentifier(t.name)&&(this.DEBUG&&console.log(`${t.name.getFullText()} is a value (from module declaration)`),this.values.add(t.name.text)),this.analyze(t.getChildren());continue}this.DEBUG&&console.log("unhandled statement",t.getFullText(),t.kind)}}isUselessImport(e){const t=this.service.findReferenceCount(e),r=this.typeHints.get(e.text);return r&&r+1>=t}isTypeOnly(e){return this.typeHints.has(e)||this.types.has(e)&&!this.values.has(e)}isReExportTypeOnly(e){return this.reExportTypeHints.has(e)}}function Be(n){const e=n.getFullText().match(/^(?:\n*)([ ]*)/);return" ".repeat(e?.[1]?.length||0)}a(Be,"getNodeIndent");function ke(n,e,t){for(const r of n.statements)ee(e,r),i.isModuleDeclaration(r)&&r.body&&i.isModuleBlock(r.body)&&ke(r.body,e)}a(ke,"preProcessNamespaceBody");function mn({sourceFile:n,isEntry:e,isJSON:t}){const r=new G(n.getFullText()),s=!e&&dn(n),o=new Set,c=new Set;let l="";const d=new Map,m=new Map;for(const f of n.statements){if(i.isEmptyStatement(f)){r.remove(f.getStart(),f.getEnd());continue}if(i.isImportDeclaration(f)){if(!f.importClause)continue;f.importClause.name&&o.add(f.importClause.name.text),f.importClause.namedBindings&&(i.isNamespaceImport(f.importClause.namedBindings)?o.add(f.importClause.namedBindings.name.text):f.importClause.namedBindings.elements.forEach(g=>o.add(g.name.text)))}else if(i.isEnumDeclaration(f)||i.isFunctionDeclaration(f)||i.isInterfaceDeclaration(f)||i.isClassDeclaration(f)||i.isTypeAliasDeclaration(f)||i.isModuleDeclaration(f)){if(f.name){const g=f.name.getText();o.add(g),z(f,i.ModifierFlags.ExportDefault)?l=g:(s&&i.isIdentifier(f.name)||z(f,i.ModifierFlags.Export))&&c.add(g),f.flags&i.NodeFlags.GlobalAugmentation||T(g,[te(f),je(f)])}i.isModuleDeclaration(f)&&(f.body&&i.isModuleBlock(f.body)&&ke(f.body,r),hn(r,f)),ee(r,f)}else if(i.isVariableStatement(f)){const{declarations:g}=f.declarationList,E=z(f,i.ModifierFlags.Export);for(const I of f.declarationList.declarations)if(i.isIdentifier(I.name)){const R=I.name.getText();o.add(R),(s||E)&&c.add(R)}if(ee(r,f),g.length===1){const I=g[0];i.isIdentifier(I.name)&&T(I.name.getText(),[te(f),je(f)])}else{const I=g.slice(),R=I.shift();T(R.name.getText(),[te(f),R.getEnd()]);for(const P of I)i.isIdentifier(P.name)&&T(P.name.getText(),[P.getFullStart(),P.getEnd()])}const{flags:C}=f.declarationList,M=`declare ${C&i.NodeFlags.Let?"let":C&i.NodeFlags.Const?"const":"var"} `,F=f.declarationList.getChildren().find(I=>I.kind===i.SyntaxKind.SyntaxList).getChildren();let O=0;for(const I of F)if(I.kind===i.SyntaxKind.CommaToken)O=I.getStart(),r.remove(O,I.getEnd());else if(O){r.appendLeft(O,`;
`);const R=I.getFullStart(),P=r.slice(R,I.getStart()),re=P.length-P.trimStart().length;re?r.overwrite(R,R+re,M):r.appendLeft(R,M)}}}for(const f of n.statements){if(h(f),i.isExportAssignment(f)&&!f.isExportEquals&&(i.isObjectLiteralExpression(f.expression)||i.isArrayLiteralExpression(f.expression))){l||(l=S("export_default")),r.overwrite(f.getStart(),f.expression.getStart(),`declare var ${l} = `);continue}if(z(f,i.ModifierFlags.ExportDefault)&&(i.isFunctionDeclaration(f)||i.isClassDeclaration(f))){if(f.name)continue;l||(l=S("export_default"));const g=f.getChildren(),E=g.findIndex(F=>F.kind===i.SyntaxKind.ClassKeyword||F.kind===i.SyntaxKind.FunctionKeyword),C=g[E],N=g[E+1];if(N.kind>=i.SyntaxKind.FirstPunctuation&&N.kind<=i.SyntaxKind.LastPunctuation){const F=r.slice(C.getEnd(),N.getStart())!=" ";r.appendLeft(N.getStart(),`${F?" ":""}${l}`)}else r.appendRight(C.getEnd(),` ${l}`)}}for(const f of m.values()){const E=f.pop()[0];for(const C of f)r.move(C[0],C[1],E)}l&&r.append(`
export default ${l};
`),c.size&&r.append(`
export { ${[...c].join(", ")} };
`),t&&c.size&&(l=S("export_default"),r.append([`
declare const ${l}: {`,[...c].map(f=>`  ${f}: typeof ${f};`).join(`
`),"};",`export default ${l};
`].join(`
`)));for(const[f,g]of d.entries())r.prepend(`import * as ${g} from "${f}";
`);const u=n.getLineStarts(),y=new Set;for(const f of n.typeReferenceDirectives){y.add(f.fileName);const{line:g}=n.getLineAndCharacterOfPosition(f.pos),E=u[g];let C=n.getLineEndOfPosition(f.pos);r.slice(C,C+1)===`
`&&(C+=1),r.remove(E,C)}const p=new Set;for(const f of n.referencedFiles){p.add(f.fileName);const{line:g}=n.getLineAndCharacterOfPosition(f.pos),E=u[g];let C=n.getLineEndOfPosition(f.pos);r.slice(C,C+1)===`
`&&(C+=1),r.remove(E,C)}return{code:r,typeReferences:y,fileReferences:p};function h(f){if(i.forEachChild(f,h),i.isImportTypeNode(f)){if(!i.isLiteralTypeNode(f.argument)||!i.isStringLiteral(f.argument.literal))throw new w(f,"inline imports should have a literal argument");const g=f.argument.literal.text,E=f.getChildren(),C=E.find(O=>O.kind===i.SyntaxKind.ImportKeyword).getStart();let N=f.getEnd();const M=E.find(O=>O.kind===i.SyntaxKind.DotToken||O.kind===i.SyntaxKind.LessThanToken);M&&(N=M.getStart());const F=x(g);r.overwrite(C,N,F)}}function x(f){let g=d.get(f);return g||(g=S(yn(f)),d.set(f,g)),g}function S(f){let g=f;for(;o.has(g);)g=`_${g}`;return o.add(g),g}function T(f,g){let E=m.get(f);if(!E)E=[g],m.set(f,E);else{const C=E[E.length-1];C[1]===g[0]?C[1]=g[1]:E.push(g)}}}a(mn,"preProcess");function dn(n){let e=!1;for(const t of n.statements){if(i.isExportDeclaration(t)||i.isExportAssignment(t))return!1;(e||i.isImportDeclaration(t)||z(t,i.ModifierFlags.Export))&&(e=!0)}return e}a(dn,"isGlobalModule");function ee(n,e){if(!i.canHaveModifiers(e))return;if(e.parent.kind===i.SyntaxKind.SourceFile){let r=!1;const s=i.isEnumDeclaration(e)||i.isClassDeclaration(e)||i.isFunctionDeclaration(e)||i.isModuleDeclaration(e)||i.isVariableStatement(e);for(const o of e.modifiers??[])switch(o.kind){case i.SyntaxKind.ExportKeyword:case i.SyntaxKind.DefaultKeyword:n.remove(o.getStart(),o.getEnd()+1);break;case i.SyntaxKind.DeclareKeyword:r=!0}s&&!r&&n.appendRight(e.getStart(),"declare ")}}a(ee,"fixModifiers");function hn(n,e){if(!(!e.body||!i.isModuleBlock(e.body))){for(const t of e.body.statements)if(i.isExportDeclaration(t)&&t.exportClause){if(i.isNamespaceExport(t.exportClause))continue;for(const r of t.exportClause.elements)r.propertyName||n.appendLeft(r.name.getEnd(),` as ${r.name.getText()}`)}}}a(hn,"duplicateExports");function yn(n){return n.replace(/[^a-zA-Z0-9_$]/g,()=>"_")}a(yn,"getSafeName");function te(n){const e=n.getFullStart();return e+(Ue(n,e)?1:0)}a(te,"getStart");function je(n){const e=n.getEnd();return e+(Ue(n,e)?1:0)}a(je,"getEnd");function Ue(n,e){return n.getSourceFile().getFullText()[e]===`
`}a(Ue,"newlineAt");const gn=new Set([i.SyntaxKind.LiteralType,i.SyntaxKind.VoidKeyword,i.SyntaxKind.UnknownKeyword,i.SyntaxKind.AnyKeyword,i.SyntaxKind.BooleanKeyword,i.SyntaxKind.NumberKeyword,i.SyntaxKind.StringKeyword,i.SyntaxKind.ObjectKeyword,i.SyntaxKind.NullKeyword,i.SyntaxKind.UndefinedKeyword,i.SyntaxKind.SymbolKeyword,i.SyntaxKind.NeverKeyword,i.SyntaxKind.ThisKeyword,i.SyntaxKind.ThisType,i.SyntaxKind.BigIntKeyword]);class Ke{static{a(this,"DeclarationScope")}constructor({id:e,range:t}){if(this.scopes=[],e)this.declaration=un(e,t);else{const{iife:s,fn:o}=cn(t);this.iife=s,this.declaration=o}const r=ln();this.declaration.body.body.push(r.stmt),this.returnExpr=r.expr}pushScope(){this.scopes.push(new Set)}popScope(e=1){for(let t=0;t<e;t++)this.scopes.pop()}pushTypeVariable(e){const t=e.getText();this.scopes[this.scopes.length-1]?.add(t)}pushReference(e){let t;if(e.type==="Identifier"?t=e.name:e.type==="MemberExpression"&&e.object.type==="Identifier"&&(t=e.object.name),t){for(const o of this.scopes)if(o.has(t))return}if(t==="this")return;const{ident:r,expr:s}=an(e);this.declaration.params.push(s),this.returnExpr.elements.push(r)}pushIdentifierReference(e){this.pushReference(b(e))}convertEntityName(e){return i.isIdentifier(e)?b(e):D({type:"MemberExpression",computed:!1,optional:!1,object:this.convertEntityName(e.left),property:b(e.right)},e)}convertPropertyAccess(e){if(!i.isIdentifier(e.expression)&&!i.isPropertyAccessExpression(e.expression))throw new w(e.expression);if(i.isPrivateIdentifier(e.name))throw new w(e.name);const t=i.isIdentifier(e.expression)?b(e.expression):this.convertPropertyAccess(e.expression);return D({type:"MemberExpression",computed:!1,optional:!1,object:t,property:b(e.name)},e)}convertComputedPropertyName(e){if(!e.name||!i.isComputedPropertyName(e.name))return;const{expression:t}=e.name;if(!(i.isLiteralExpression(t)||i.isPrefixUnaryExpression(t))){if(i.isIdentifier(t))return this.pushReference(b(t));if(i.isPropertyAccessExpression(t))return this.pushReference(this.convertPropertyAccess(t));throw new w(t)}}convertParametersAndType(e){this.convertComputedPropertyName(e);const t=this.convertTypeParameters(e.typeParameters);for(const r of e.parameters)this.convertTypeNode(r.type);this.convertTypeNode(e.type),this.popScope(t)}convertHeritageClauses(e){for(const t of e.heritageClauses||[])for(const r of t.types)this.pushReference(A(r.expression)),this.convertTypeArguments(r)}convertTypeArguments(e){if(e.typeArguments)for(const t of e.typeArguments)this.convertTypeNode(t)}convertMembers(e){for(const t of e){if(i.isPropertyDeclaration(t)||i.isPropertySignature(t)||i.isIndexSignatureDeclaration(t)){i.isPropertyDeclaration(t)&&t.initializer&&i.isPropertyAccessExpression(t.initializer)&&this.pushReference(this.convertPropertyAccess(t.initializer)),this.convertComputedPropertyName(t),this.convertTypeNode(t.type);continue}if(i.isMethodDeclaration(t)||i.isMethodSignature(t)||i.isConstructorDeclaration(t)||i.isConstructSignatureDeclaration(t)||i.isCallSignatureDeclaration(t)||i.isGetAccessorDeclaration(t)||i.isSetAccessorDeclaration(t))this.convertParametersAndType(t);else throw new w(t)}}convertTypeParameters(e){if(!e)return 0;for(const t of e)this.convertTypeNode(t.constraint),this.convertTypeNode(t.default),this.pushScope(),this.pushTypeVariable(t.name);return e.length}convertTypeNode(e){if(e&&!gn.has(e.kind)){if(i.isTypeReferenceNode(e)){this.pushReference(this.convertEntityName(e.typeName)),this.convertTypeArguments(e);return}if(i.isTypeLiteralNode(e)){this.convertMembers(e.members);return}if(i.isArrayTypeNode(e)){this.convertTypeNode(e.elementType);return}if(i.isTupleTypeNode(e)){for(const t of e.elements)this.convertTypeNode(t);return}if(i.isNamedTupleMember(e)||i.isParenthesizedTypeNode(e)||i.isTypeOperatorNode(e)||i.isTypePredicateNode(e)){this.convertTypeNode(e.type);return}if(i.isUnionTypeNode(e)||i.isIntersectionTypeNode(e)){for(const t of e.types)this.convertTypeNode(t);return}if(i.isMappedTypeNode(e)){const{typeParameter:t,type:r,nameType:s}=e;this.convertTypeNode(t.constraint),this.pushScope(),this.pushTypeVariable(t.name),this.convertTypeNode(r),s&&this.convertTypeNode(s),this.popScope();return}if(i.isConditionalTypeNode(e)){this.convertTypeNode(e.checkType),this.pushScope(),this.convertTypeNode(e.extendsType),this.convertTypeNode(e.trueType),this.convertTypeNode(e.falseType),this.popScope();return}if(i.isIndexedAccessTypeNode(e)){this.convertTypeNode(e.objectType),this.convertTypeNode(e.indexType);return}if(i.isFunctionOrConstructorTypeNode(e)){this.convertParametersAndType(e);return}if(i.isTypeQueryNode(e)){const t=this.convertEntityName(e.exprName);this.pushReference(t),this.convertTypeArguments(e);return}if(i.isRestTypeNode(e)){this.convertTypeNode(e.type);return}if(i.isOptionalTypeNode(e)){this.convertTypeNode(e.type);return}if(i.isTemplateLiteralTypeNode(e)){for(const t of e.templateSpans)this.convertTypeNode(t.type);return}if(i.isInferTypeNode(e)){const{typeParameter:t}=e;this.convertTypeNode(t.constraint),this.pushTypeVariable(t.name);return}else throw new w(e)}}convertNamespace(e,t=!1){if(this.pushScope(),t&&e.body&&i.isModuleDeclaration(e.body)){this.convertNamespace(e.body,!0);return}if(!e.body||!i.isModuleBlock(e.body))throw new w(e,'namespace must have a "ModuleBlock" body.');const{statements:r}=e.body;for(const s of r){if(i.isEnumDeclaration(s)||i.isFunctionDeclaration(s)||i.isClassDeclaration(s)||i.isInterfaceDeclaration(s)||i.isTypeAliasDeclaration(s)||i.isModuleDeclaration(s)){if(s.name&&i.isIdentifier(s.name))this.pushTypeVariable(s.name);else throw new w(s,"non-Identifier name not supported");continue}if(i.isVariableStatement(s)){for(const o of s.declarationList.declarations)if(i.isIdentifier(o.name))this.pushTypeVariable(o.name);else throw new w(o,"non-Identifier name not supported");continue}if(i.isImportDeclaration(s)){if(s.importClause&&(s.importClause.name&&this.pushTypeVariable(s.importClause.name),s.importClause.namedBindings))if(i.isNamespaceImport(s.importClause.namedBindings))this.pushTypeVariable(s.importClause.namedBindings.name);else for(const o of s.importClause.namedBindings.elements)this.pushTypeVariable(o.name);continue}if(i.isImportEqualsDeclaration(s)){this.pushTypeVariable(s.name);continue}if(!i.isExportDeclaration(s))throw new w(s,"namespace child (hoisting) not supported yet")}for(const s of r){if(i.isVariableStatement(s)){for(const o of s.declarationList.declarations)o.type&&this.convertTypeNode(o.type);continue}if(i.isFunctionDeclaration(s)){this.convertParametersAndType(s);continue}if(i.isInterfaceDeclaration(s)||i.isClassDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertHeritageClauses(s),this.convertMembers(s.members),this.popScope(o);continue}if(i.isTypeAliasDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertTypeNode(s.type),this.popScope(o);continue}if(i.isModuleDeclaration(s)){this.convertNamespace(s,t);continue}if(!i.isEnumDeclaration(s)&&!i.isImportDeclaration(s)){if(i.isImportEqualsDeclaration(s)){i.isEntityName(s.moduleReference)&&this.pushReference(this.convertEntityName(s.moduleReference));continue}if(i.isExportDeclaration(s)){if(s.exportClause){if(i.isNamespaceExport(s.exportClause))throw new w(s.exportClause);for(const o of s.exportClause.elements){const c=o.propertyName||o.name;this.pushIdentifierReference(c)}}}else throw new w(s,"namespace child (walking) not supported yet")}}this.popScope()}}function xn({sourceFile:n}){return new Sn(n).transform()}a(xn,"convert");class Sn{static{a(this,"Transformer")}constructor(e){this.sourceFile=e,this.declarations=new Map,this.ast=on(e);for(const t of e.statements)this.convertStatement(t)}transform(){return{ast:this.ast}}pushStatement(e){this.ast.body.push(e)}createDeclaration(e,t){const r={start:e.getFullStart(),end:e.getEnd()};if(!t){const l=new Ke({range:r});return this.pushStatement(l.iife),l}const s=t.getText(),o=new Ke({id:t,range:r}),c=this.declarations.get(s);if(c){c.pushIdentifierReference(t),c.declaration.end=r.end;const l=this.ast.body.findIndex(d=>d==c.declaration);for(let d=l+1;d<this.ast.body.length;d++){const m=this.ast.body[d];m.start=m.end=r.end}}else this.pushStatement(o.declaration),this.declarations.set(s,o);return c||o}convertStatement(e){if(i.isEnumDeclaration(e))return this.convertEnumDeclaration(e);if(i.isFunctionDeclaration(e))return this.convertFunctionDeclaration(e);if(i.isInterfaceDeclaration(e)||i.isClassDeclaration(e))return this.convertClassOrInterfaceDeclaration(e);if(i.isTypeAliasDeclaration(e))return this.convertTypeAliasDeclaration(e);if(i.isVariableStatement(e))return this.convertVariableStatement(e);if(i.isExportDeclaration(e)||i.isExportAssignment(e))return this.convertExportDeclaration(e);if(i.isModuleDeclaration(e))return this.convertNamespaceDeclaration(e);if(e.kind===i.SyntaxKind.NamespaceExportDeclaration)return this.removeStatement(e);if(i.isImportDeclaration(e)||i.isImportEqualsDeclaration(e))return this.convertImportDeclaration(e);throw new w(e)}removeStatement(e){this.pushStatement(D({type:"ExpressionStatement",expression:{type:"Literal",value:"pls remove me"}},e))}convertNamespaceDeclaration(e){if(e.flags&i.NodeFlags.GlobalAugmentation||!i.isIdentifier(e.name)){this.createDeclaration(e).convertNamespace(e,!0);return}const r=this.createDeclaration(e,e.name);r.pushIdentifierReference(e.name),r.convertNamespace(e)}convertEnumDeclaration(e){this.createDeclaration(e,e.name).pushIdentifierReference(e.name)}convertFunctionDeclaration(e){if(!e.name)throw new w(e,"FunctionDeclaration should have a name");const t=this.createDeclaration(e,e.name);t.pushIdentifierReference(e.name),t.convertParametersAndType(e)}convertClassOrInterfaceDeclaration(e){if(!e.name)throw new w(e,"ClassDeclaration / InterfaceDeclaration should have a name");const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertHeritageClauses(e),t.convertMembers(e.members),t.popScope(r)}convertTypeAliasDeclaration(e){const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertTypeNode(e.type),t.popScope(r)}convertVariableStatement(e){const{declarations:t}=e.declarationList;if(t.length!==1)throw new w(e,"VariableStatement with more than one declaration not yet supported");for(const r of t){if(!i.isIdentifier(r.name))throw new w(e,"VariableDeclaration must have a name");const s=this.createDeclaration(e,r.name);s.convertTypeNode(r.type),r.initializer&&this.trackExpressionReferences(r.initializer,s)}}trackExpressionReferences(e,t){if(i.isIdentifier(e))t.pushIdentifierReference(e);else if(i.isObjectLiteralExpression(e))for(const r of e.properties)i.isShorthandPropertyAssignment(r)?t.pushIdentifierReference(r.name):i.isPropertyAssignment(r)&&this.trackExpressionReferences(r.initializer,t);else if(i.isArrayLiteralExpression(e))for(const r of e.elements)i.isExpression(r)&&this.trackExpressionReferences(r,t);else i.isPropertyAccessExpression(e)&&this.trackExpressionReferences(e.expression,t)}convertExportDeclaration(e){if(i.isExportAssignment(e)){this.pushStatement(D({type:"ExportDefaultDeclaration",declaration:A(e.expression)},e));return}const t=e.moduleSpecifier?A(e.moduleSpecifier):void 0;if(!e.exportClause)this.pushStatement(D({type:"ExportAllDeclaration",source:t,exported:null,attributes:[]},e));else if(i.isNamespaceExport(e.exportClause))this.pushStatement(D({type:"ExportAllDeclaration",source:t,exported:b(e.exportClause.name),attributes:[]},e));else{const r=[];for(const s of e.exportClause.elements)r.push(this.convertExportSpecifier(s));this.pushStatement(D({type:"ExportNamedDeclaration",declaration:null,specifiers:r,source:t,attributes:[]},e))}}convertImportDeclaration(e){if(i.isImportEqualsDeclaration(e)){if(i.isEntityName(e.moduleReference)){const s=this.createDeclaration(e,e.name);s.pushReference(s.convertEntityName(e.moduleReference));return}if(!i.isExternalModuleReference(e.moduleReference))throw new w(e,"ImportEquals should have a literal source.");this.pushStatement(D({type:"ImportDeclaration",specifiers:[{type:"ImportDefaultSpecifier",local:b(e.name)}],source:A(e.moduleReference.expression),attributes:[]},e));return}const t=A(e.moduleSpecifier),r=e.importClause&&e.importClause.namedBindings?this.convertNamedImportBindings(e.importClause.namedBindings):[];e.importClause&&e.importClause.name&&r.push({type:"ImportDefaultSpecifier",local:b(e.importClause.name)}),this.pushStatement(D({type:"ImportDeclaration",specifiers:r,source:t,attributes:[]},e))}convertNamedImportBindings(e){return i.isNamedImports(e)?e.elements.map(t=>{const r=b(t.name),s=t.propertyName?b(t.propertyName):r;return{type:"ImportSpecifier",local:r,imported:s}}):[{type:"ImportNamespaceSpecifier",local:b(e.name)}]}convertExportSpecifier(e){const t=b(e.name);return{type:"ExportSpecifier",exported:t,local:e.propertyName?b(e.propertyName):t}}}class vn{static{a(this,"RelativeModuleDeclarationFixer")}constructor(e,t,r,s){this.sourcemap=r,this.DEBUG=!!process.env.DTS_EXPORTS_FIXER_DEBUG,this.relativeModuleDeclarations=[],this.source=U(e,t.toString()),this.code=t,this.name=s||"./index"}fix(){this.analyze(this.source.statements);for(const e of this.relativeModuleDeclarations){const t=e.getStart(),r=e.getEnd(),s=e.name.kind===i.SyntaxKind.StringLiteral&&"singleQuote"in e.name&&e.name.singleQuote?"'":'"',o=`declare module ${s}${this.name}${s} ${e.body.getText()}`;this.code.overwrite(t,r,o)}return{code:this.code.toString(),map:this.relativeModuleDeclarations.length&&this.sourcemap?this.code.generateMap():null}}analyze(e){for(const t of e)i.isModuleDeclaration(t)&&t.body&&i.isModuleBlock(t.body)&&/^\.\.?\//.test(t.name.text)&&(this.DEBUG&&console.log(`Found relative module declaration: ${t.name.text} in ${this.source.fileName}`),this.relativeModuleDeclarations.push(t))}}function En(n,e,t){const r=W(n),s=W(e.mappings),o=t.split(`
`),c=[];for(let l=0;l<r.length;l+=1){const d=r[l];if(!d||d.length===0){c.push([]);continue}const m=d.find(g=>g.length>=4);if(!m){c.push(d);continue}const[,u,y]=m;if(u!==0||y===void 0||y<0||y>=s.length){c.push(d);continue}const p=s[y];if(!p||p.length===0){c.push(d);continue}const h=m[0],x=m.length>=4?m[3]:0,S=h-(x??0),T=o[l]||"",f=[];for(const g of p){const E=g[0]+S;E<0||E>T.length||(g.length===5?f.push([E,g[1],g[2],g[3],g[4]]):g.length===4?f.push([E,g[1],g[2],g[3]]):f.push([E]))}f.sort((g,E)=>g[0]-E[0]),c.push(f)}return fe(c)}a(En,"hydrateSourcemap");async function Nn(n){const{fileName:e,originalCode:t}=n,r=Re.fromSource(t);if(r)return r.toObject();const s=a(async o=>{const c=o.split(/[?#]/)[0],l=v.resolve(v.dirname(e),c);return se.readFile(l,"utf8")},"readMap");try{const o=await Re.fromMapFileSource(t,s);if(o)return o.toObject()}catch{}try{const o=await se.readFile(e+".map","utf8");return JSON.parse(o)}catch{return null}}a(Nn,"loadInputSourcemap");const Tn=a(()=>{const n=new Map,e=new Map,t=new Map;return{name:"dts-transform",buildStart(){n.clear(),e.clear(),t.clear()},options({onLog:r,...s}){return{...s,onLog(o,c,l){o==="warn"&&c.code==="CIRCULAR_DEPENDENCY"||(r?r(o,c,l):l(o,c))},treeshake:{moduleSideEffects:"no-external",propertyReadSideEffects:!0,unknownGlobalSideEffects:!1}}},outputOptions(r){return{...r,chunkFileNames:r.chunkFileNames||"[name]-[hash].d.ts",entryFileNames:r.entryFileNames||"[name].d.ts",format:"es",exports:"named",compact:!1,freeze:!0,interop:"esModule",generatedCode:Object.assign({symbols:!1},r.generatedCode),strict:!1}},transform(r,s){const o=Q(s),c=this.getModuleIds(),l=Array.from(c).find(x=>Q(x)===o),d=!!(l&&this.getModuleInfo(l)?.isEntry),m=!!(l&&X.test(l));let u=U(s,r);const y=mn({sourceFile:u,isEntry:d,isJSON:m});n.set(u.fileName,y.typeReferences),e.set(u.fileName,y.fileReferences),r=y.code.toString(),u=U(s,r);const p=xn({sourceFile:u});process.env.DTS_DUMP_AST&&(console.log(s),console.log(r),console.log(JSON.stringify(p.ast.body,void 0,2)));const h=y.code.generateMap({hires:!0,source:s});return _.test(s)&&t.set(s,{fileName:s,originalCode:r}),{code:r,ast:p.ast,map:h}},renderChunk(r,s,o){const c=U(s.fileName,r),l=new sn(c),d=new Set,m=new Set;for(const x of Object.keys(s.modules)){for(const S of n.get(x.split("\\").join("/"))||[])d.add(S);for(const S of e.get(x.split("\\").join("/"))||[])if(S.startsWith(".")){const T=v.join(v.dirname(x),S),f=o.file&&v.dirname(o.file)||s.facadeModuleId&&v.dirname(s.facadeModuleId)||".";let g=v.relative(f,T).split("\\").join("/");g[0]!=="."&&(g="./"+g),m.add(g)}else m.add(S)}let u=ze(Array.from(m,x=>`/// <reference path="${x}" />`));u+=ze(Array.from(d,x=>`/// <reference types="${x}" />`)),u+=l.fix(),u||(u+=`
export { };`);const p=new fn(s.fileName,u).fix();return new vn(s.fileName,"magicCode"in p&&p.magicCode?p.magicCode:new G(u),!!o.sourcemap,"./"+v.basename(s.fileName,".d.ts")).fix()},async generateBundle(r,s){if(!r.sourcemap)return;const o=new Map,c=Array.from(t.entries()),l=await Promise.all(c.map(async([u,y])=>({fileName:u,inputMap:await Nn(y)}))),d=a(u=>/^[a-z][a-z0-9+.-]*:\/\//i.test(u),"isUrl");for(const{fileName:u,inputMap:y}of l)if(y&&y.sources){const p=v.dirname(u);let h;y.sourceRoot?h=d(y.sourceRoot)?y.sourceRoot:v.resolve(p,y.sourceRoot):h=p;const x=d(h);o.set(u,{version:y.version??3,sources:y.sources.map(S=>{if(S===null)return null;if(d(S))return S;if(x){const T=h.endsWith("/")?h:h+"/";return new URL(S,T).toString()}return v.isAbsolute(S)?S:v.resolve(h,S)}),mappings:y.mappings,names:y.names})}const m=r.dir||(r.file?v.dirname(r.file):process.cwd());for(const u of Object.values(s)){if(u.type!=="chunk"||!u.map)continue;const y=v.join(m,v.dirname(u.fileName)),p=a(N=>d(N)?N:(v.isAbsolute(N)?v.relative(y,N):N).replaceAll("\\","/"),"toRelativeSourcePath"),h=a(N=>N===null?null:p(N),"toRelativeSourcePathOrNull"),x=new Map;for(const N of u.map.sources){if(!N||d(N))continue;const M=v.resolve(y,N),F=o.get(M);F&&x.set(M,F)}if(x.size===0){if(delete u.map.sourcesContent,u.map.sources.length===0&&u.facadeModuleId){const N=o.get(u.facadeModuleId);if(N&&N.sources.length>0){const M=N.sources.map(h);u.map.sources=M,Ve(s,u.fileName,{sources:M,mappings:u.map.mappings,names:u.map.names||[]})}}continue}const T=u.map.sources.length===1&&x.size===1?Array.from(x.values())[0]:null,f=T&&T.sources.length===1;let g,E,C;if(f&&T)g=T.sources.map(h),E=En(u.map.mappings,T,u.code),C=T.names||[];else{const N=Wt(u.map,M=>{const F=v.resolve(y,M),O=x.get(F);return O||null});g=N.sources.map(h),E=typeof N.mappings=="string"?N.mappings:"",C=N.names||[]}u.map.sources=g,delete u.map.sourcesContent,u.map.mappings=E,u.map.names=C,Ve(s,u.fileName,{sources:g,mappings:E,names:C})}}}},"transform");function ze(n){return n.length?n.join(`
`)+`
`:""}a(ze,"writeBlock");function Ve(n,e,t){const r=`${e}.map`,s=n[r];s&&s.type==="asset"&&(s.source=JSON.stringify({version:3,file:v.basename(e),...t}))}a(Ve,"updateSourcemapAsset");const Cn=/\.([cm]ts|[tj]sx?)$/;function ne({entries:n,programs:e,resolvedOptions:t},r,s){const{compilerOptions:o,tsconfig:c}=t;if(!e.length&&_.test(r))return{code:s};const l=n.includes(r),d=e.find(m=>{if(l)return m.getRootFileNames().includes(r);{const u=m.getSourceFile(r);return u&&m.isSourceFileFromExternalLibrary(u)?!1:!!u}});if(d){const m=d.getSourceFile(r);return{code:m?.getFullText(),source:m,program:d}}else if(i.sys.fileExists(r)){if(e.length>0&&_.test(r)&&(t.includeExternal.length>0||t.respectExternal))return{code:s};const m=Zt(r,o,c);e.push(m);const u=m.getSourceFile(r);return{code:u?.getFullText(),source:u,program:m}}else return null}a(ne,"getModule");const Je=a((n={})=>{const e=Tn(),t={entries:[],programs:[],resolvedOptions:Qt(n)};return{name:"dts",outputOptions:e.outputOptions,renderChunk:e.renderChunk,generateBundle:e.generateBundle,options(r){let{input:s=[]}=r;if(!Array.isArray(s))s=typeof s=="string"?[s]:Object.values(s);else if(s.length>1){r.input={};for(const o of s){let c=Q(o);v.isAbsolute(o)?c=v.basename(c):c=v.normalize(c),r.input[c]=o}}return t.programs=en(Object.values(s),t.resolvedOptions.compilerOptions,t.resolvedOptions.tsconfig),e.options.call(this,r)},transform(r,s){if(!Cn.test(s)&&!X.test(s))return null;const o=a(m=>{if(m.program){const u=v.dirname(s);m.program.getSourceFiles().map(p=>p.fileName).filter(p=>p.startsWith(u)).forEach(this.addWatchFile)}},"watchFiles"),c=a(()=>{const m=ne(t,s,r);return m?(o(m),e.transform.call(this,m.code,s)):null},"handleDtsFile"),l=a(()=>{const m=Pe(s),u=ne(t,m,r);return u?(o(u),e.transform.call(this,u.code,m)):null},"treatTsAsDts"),d=a(()=>{const m=ne(t,s,r);if(!m||!m.source||!m.program)return null;o(m);const u=Pe(s);let y;const{emitSkipped:p,diagnostics:h}=m.program.emit(m.source,(x,S)=>{y=e.transform.call(this,S,u)},void 0,!0,void 0,!0);if(p){const x=h.filter(S=>S.category===i.DiagnosticCategory.Error);x.length&&(console.error(i.formatDiagnostics(x,Y)),this.error("Failed to compile. Check the logs above."))}return y},"generateDts");return _.test(s)?c():X.test(s)?d():l()??d()},resolveId(r,s){if(!s){t.entries.push(v.resolve(r));return}s=s.split("\\").join("/");let o=t.resolvedOptions.compilerOptions;if(t.resolvedOptions.tsconfig){const l=r.startsWith(".")?v.resolve(v.dirname(s),r):r;o=Z(l,t.resolvedOptions.compilerOptions,t.resolvedOptions.tsconfig).compilerOptions}const{resolvedModule:c}=i.resolveModuleName(r,s,o,i.sys);if(c)return c.isExternalLibraryImport&&c.packageId&&t.resolvedOptions.includeExternal.includes(c.packageId.name)?{id:v.resolve(c.resolvedFileName)}:!t.resolvedOptions.respectExternal&&c.isExternalLibraryImport?{id:r,external:!0}:{id:v.resolve(c.resolvedFileName)}}}},"plugin");export{Je as default,Je as dts};
