var We=Object.defineProperty;var c=(n,e)=>We(n,"name",{value:e,configurable:!0});import{createRequire as Ge}from"node:module";const qe=Ge(import.meta.url);import*as N from"node:path";import i from"typescript";import{createRequire as He}from"node:module";import W from"magic-string";import se from"node:fs/promises";var ie=44,Xe=59,oe="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",ae=new Uint8Array(64),ce=new Uint8Array(128);for(let n=0;n<oe.length;n++){const e=oe.charCodeAt(n);ae[n]=e,ce[e]=n}function B(n,e){let t=0,r=0,s=0;do{const a=n.next();s=ce[a],t|=(s&31)<<r,r+=5}while(s&32);const o=t&1;return t>>>=1,o&&(t=-2147483648|-t),e+t}c(B,"decodeInteger");function j(n,e,t){let r=e-t;r=r<0?-r<<1|1:r<<1;do{let s=r&31;r>>>=5,r>0&&(s|=32),n.write(ae[s])}while(r>0);return e}c(j,"encodeInteger");function le(n,e){return n.pos>=e?!1:n.peek()!==ie}c(le,"hasMoreVlq");var ue=1024*16,pe=typeof TextDecoder<"u"?new TextDecoder:typeof Buffer<"u"?{decode(n){return Buffer.from(n.buffer,n.byteOffset,n.byteLength).toString()}}:{decode(n){let e="";for(let t=0;t<n.length;t++)e+=String.fromCharCode(n[t]);return e}},Qe=class{static{c(this,"StringWriter")}constructor(){this.pos=0,this.out="",this.buffer=new Uint8Array(ue)}write(n){const{buffer:e}=this;e[this.pos++]=n,this.pos===ue&&(this.out+=pe.decode(e),this.pos=0)}flush(){const{buffer:n,out:e,pos:t}=this;return t>0?e+pe.decode(n.subarray(0,t)):e}},Ye=class{static{c(this,"StringReader")}constructor(n){this.pos=0,this.buffer=n}next(){return this.buffer.charCodeAt(this.pos++)}peek(){return this.buffer.charCodeAt(this.pos)}indexOf(n){const{buffer:e,pos:t}=this,r=e.indexOf(n,t);return r===-1?e.length:r}};function G(n){const{length:e}=n,t=new Ye(n),r=[];let s=0,o=0,a=0,u=0,m=0;do{const f=t.indexOf(";"),d=[];let h=!0,l=0;for(s=0;t.pos<f;){let y;s=B(t,s),s<l&&(h=!1),l=s,le(t,f)?(o=B(t,o),a=B(t,a),u=B(t,u),le(t,f)?(m=B(t,m),y=[s,o,a,u,m]):y=[s,o,a,u]):y=[s],d.push(y),t.pos++}h||Ze(d),r.push(d),t.pos=f+1}while(t.pos<=e);return r}c(G,"decode");function Ze(n){n.sort(et)}c(Ze,"sort");function et(n,e){return n[0]-e[0]}c(et,"sortComparator$1");function fe(n){const e=new Qe;let t=0,r=0,s=0,o=0;for(let a=0;a<n.length;a++){const u=n[a];if(a>0&&e.write(Xe),u.length===0)continue;let m=0;for(let f=0;f<u.length;f++){const d=u[f];f>0&&e.write(ie),m=j(e,d[0],m),d.length!==1&&(t=j(e,d[1],t),r=j(e,d[2],r),s=j(e,d[3],s),d.length!==4&&(o=j(e,d[4],o)))}}return e.flush()}c(fe,"encode");const tt=/^[\w+.-]+:\/\//,nt=/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,rt=/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;function st(n){return tt.test(n)}c(st,"isAbsoluteUrl");function it(n){return n.startsWith("//")}c(it,"isSchemeRelativeUrl");function me(n){return n.startsWith("/")}c(me,"isAbsolutePath");function ot(n){return n.startsWith("file:")}c(ot,"isFileUrl");function de(n){return/^[.?#]/.test(n)}c(de,"isRelative");function V(n){const e=nt.exec(n);return he(e[1],e[2]||"",e[3],e[4]||"",e[5]||"/",e[6]||"",e[7]||"")}c(V,"parseAbsoluteUrl");function at(n){const e=rt.exec(n),t=e[2];return he("file:","",e[1]||"","",me(t)?t:"/"+t,e[3]||"",e[4]||"")}c(at,"parseFileUrl");function he(n,e,t,r,s,o,a){return{scheme:n,user:e,host:t,port:r,path:s,query:o,hash:a,type:7}}c(he,"makeUrl");function ye(n){if(it(n)){const t=V("http:"+n);return t.scheme="",t.type=6,t}if(me(n)){const t=V("http://foo.com"+n);return t.scheme="",t.host="",t.type=5,t}if(ot(n))return at(n);if(st(n))return V(n);const e=V("http://foo.com/"+n);return e.scheme="",e.host="",e.type=n?n.startsWith("?")?3:n.startsWith("#")?2:4:1,e}c(ye,"parseUrl");function ct(n){if(n.endsWith("/.."))return n;const e=n.lastIndexOf("/");return n.slice(0,e+1)}c(ct,"stripPathFilename");function lt(n,e){ge(e,e.type),n.path==="/"?n.path=e.path:n.path=ct(e.path)+n.path}c(lt,"mergePaths");function ge(n,e){const t=e<=4,r=n.path.split("/");let s=1,o=0,a=!1;for(let m=1;m<r.length;m++){const f=r[m];if(!f){a=!0;continue}if(a=!1,f!=="."){if(f===".."){o?(a=!0,o--,s--):t&&(r[s++]=f);continue}r[s++]=f,o++}}let u="";for(let m=1;m<s;m++)u+="/"+r[m];(!u||a&&!u.endsWith("/.."))&&(u+="/"),n.path=u}c(ge,"normalizePath");function ut(n,e){if(!n&&!e)return"";const t=ye(n);let r=t.type;if(e&&r!==7){const o=ye(e),a=o.type;switch(r){case 1:t.hash=o.hash;case 2:t.query=o.query;case 3:case 4:lt(t,o);case 5:t.user=o.user,t.host=o.host,t.port=o.port;case 6:t.scheme=o.scheme}a>r&&(r=a)}ge(t,r);const s=t.query+t.hash;switch(r){case 2:case 3:return s;case 4:{const o=t.path.slice(1);return o?de(e||n)&&!de(o)?"./"+o+s:o+s:s||"."}case 5:return t.path+s;default:return t.scheme+"//"+t.user+t.host+t.port+t.path+s}}c(ut,"resolve");function pt(n){if(!n)return"";const e=n.lastIndexOf("/");return n.slice(0,e+1)}c(pt,"stripFilename");function ft(n,e){const t=pt(n),r=e?e+"/":"";return s=>ut(r+(s||""),t)}c(ft,"resolver");var L=0;function mt(n,e){const t=xe(n,0);if(t===n.length)return n;e||(n=n.slice());for(let r=t;r<n.length;r=xe(n,r+1))n[r]=ht(n[r],e);return n}c(mt,"maybeSort");function xe(n,e){for(let t=e;t<n.length;t++)if(!dt(n[t]))return t;return n.length}c(xe,"nextUnsortedSegmentLine");function dt(n){for(let e=1;e<n.length;e++)if(n[e][L]<n[e-1][L])return!1;return!0}c(dt,"isSorted");function ht(n,e){return e||(n=n.slice()),n.sort(yt)}c(ht,"sortSegments");function yt(n,e){return n[L]-e[L]}c(yt,"sortComparator");var J=!1;function gt(n,e,t,r){for(;t<=r;){const s=t+(r-t>>1),o=n[s][L]-e;if(o===0)return J=!0,s;o<0?t=s+1:r=s-1}return J=!1,t-1}c(gt,"binarySearch");function xt(n,e,t){for(let r=t-1;r>=0&&n[r][L]===e;t=r--);return t}c(xt,"lowerBound");function St(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}c(St,"memoizedState");function vt(n,e,t,r){const{lastKey:s,lastNeedle:o,lastIndex:a}=t;let u=0,m=n.length-1;if(r===s){if(e===o)return J=a!==-1&&n[a][L]===e,a;e>=o?u=a===-1?0:a:m=a}return t.lastKey=r,t.lastNeedle=e,t.lastIndex=gt(n,e,u,m)}c(vt,"memoizedBinarySearch");function Et(n){return typeof n=="string"?JSON.parse(n):n}c(Et,"parse$1");var Se=class{static{c(this,"TraceMap")}constructor(n,e){const t=typeof n=="string";if(!t&&n._decodedMemo)return n;const r=Et(n),{version:s,file:o,names:a,sourceRoot:u,sources:m,sourcesContent:f}=r;this.version=s,this.file=o,this.names=a||[],this.sourceRoot=u,this.sources=m,this.sourcesContent=f,this.ignoreList=r.ignoreList||r.x_google_ignoreList||void 0;const d=ft(e,u);this.resolvedSources=m.map(d);const{mappings:h}=r;if(typeof h=="string")this._encoded=h,this._decoded=void 0;else if(Array.isArray(h))this._encoded=void 0,this._decoded=mt(h,t);else throw r.sections?new Error("TraceMap passed sectioned source map, please use FlattenMap export instead"):new Error(`invalid source map: ${JSON.stringify(r)}`);this._decodedMemo=St(),this._bySources=void 0,this._bySourceMemos=void 0}};function On(n){return n}c(On,"cast$1");function ve(n){var e;return(e=n)._decoded||(e._decoded=G(n._encoded))}c(ve,"decodedMappings");function Nt(n,e,t){const r=ve(n);if(e>=r.length)return null;const s=r[e],o=Tt(s,n._decodedMemo,e,t);return o===-1?null:s[o]}c(Nt,"traceSegment");function Tt(n,e,t,r,s){let o=vt(n,r,e,t);return J&&(o=xt(n,r,o)),o===-1||o===n.length?-1:o}c(Tt,"traceSegmentInternal");var q=class{static{c(this,"SetArray")}constructor(){this._indexes={__proto__:null},this.array=[]}};function Rn(n){return n}c(Rn,"cast");function Ee(n,e){return n._indexes[e]}c(Ee,"get");function k(n,e){const t=Ee(n,e);if(t!==void 0)return t;const{array:r,_indexes:s}=n,o=r.push(e);return s[e]=o-1}c(k,"put");function Ct(n,e){const t=Ee(n,e);if(t===void 0)return;const{array:r,_indexes:s}=n;for(let o=t+1;o<r.length;o++){const a=r[o];r[o-1]=a,s[a]--}s[e]=void 0,r.pop()}c(Ct,"remove");var wt=0,Dt=1,bt=2,It=3,Mt=4,Ne=-1,Ft=class{static{c(this,"GenMapping")}constructor({file:n,sourceRoot:e}={}){this._names=new q,this._sources=new q,this._sourcesContent=[],this._mappings=[],this.file=n,this.sourceRoot=e,this._ignoreList=new q}};function An(n){return n}c(An,"cast2");var Ot=c((n,e,t,r,s,o,a,u)=>Lt(!0,n,e,t,r,s,o,a),"maybeAddSegment");function Rt(n,e,t){const{_sources:r,_sourcesContent:s}=n,o=k(r,e);s[o]=t}c(Rt,"setSourceContent");function At(n,e,t=!0){const{_sources:r,_sourcesContent:s,_ignoreList:o}=n,a=k(r,e);a===s.length&&(s[a]=null),t?k(o,a):Ct(o,a)}c(At,"setIgnore");function Te(n){const{_mappings:e,_sources:t,_sourcesContent:r,_names:s,_ignoreList:o}=n;return Bt(e),{version:3,file:n.file||void 0,names:s.array,sourceRoot:n.sourceRoot||void 0,sources:t.array,sourcesContent:r,mappings:e,ignoreList:o.array}}c(Te,"toDecodedMap");function Pt(n){const e=Te(n);return Object.assign({},e,{mappings:fe(e.mappings)})}c(Pt,"toEncodedMap");function Lt(n,e,t,r,s,o,a,u,m){const{_mappings:f,_sources:d,_sourcesContent:h,_names:l}=e,y=_t(f,t),x=$t(y,r);if(!s)return jt(y,x)?void 0:Ce(y,x,[r]);const S=k(d,s),v=u?k(l,u):Ne;if(S===h.length&&(h[S]=null),!kt(y,x,S,o,a,v))return Ce(y,x,u?[r,S,o,a,v]:[r,S,o,a])}c(Lt,"addSegmentInternal");function _t(n,e){for(let t=n.length;t<=e;t++)n[t]=[];return n[e]}c(_t,"getIndex");function $t(n,e){let t=n.length;for(let r=t-1;r>=0;t=r--){const s=n[r];if(e>=s[wt])break}return t}c($t,"getColumnIndex");function Ce(n,e,t){for(let r=n.length;r>e;r--)n[r]=n[r-1];n[e]=t}c(Ce,"insert");function Bt(n){const{length:e}=n;let t=e;for(let r=t-1;r>=0&&!(n[r].length>0);t=r,r--);t<e&&(n.length=t)}c(Bt,"removeEmptyFinalLines");function jt(n,e){return e===0?!0:n[e-1].length===1}c(jt,"skipSourceless");function kt(n,e,t,r,s,o){if(e===0)return!1;const a=n[e-1];return a.length===1?!1:t===a[Dt]&&r===a[bt]&&s===a[It]&&o===(a.length===5?a[Mt]:Ne)}c(kt,"skipSource");var we=De("",-1,-1,"",null,!1),Ut=[];function De(n,e,t,r,s,o){return{source:n,line:e,column:t,name:r,content:s,ignore:o}}c(De,"SegmentObject");function be(n,e,t,r,s){return{map:n,sources:e,source:t,content:r,ignore:s}}c(be,"Source");function Ie(n,e){return be(n,e,"",null,!1)}c(Ie,"MapSource");function Kt(n,e,t){return be(null,Ut,n,e,t)}c(Kt,"OriginalSource");function zt(n){const e=new Ft({file:n.map.file}),{sources:t,map:r}=n,s=r.names,o=ve(r);for(let a=0;a<o.length;a++){const u=o[a];for(let m=0;m<u.length;m++){const f=u[m],d=f[0];let h=we;if(f.length!==1){const g=t[f[1]];if(h=Me(g,f[2],f[3],f.length===5?s[f[4]]:""),h==null)continue}const{column:l,line:y,name:x,content:S,source:v,ignore:p}=h;Ot(e,a,d,v,y,l,x),v&&S!=null&&Rt(e,v,S),p&&At(e,v,!0)}}return e}c(zt,"traceMappings");function Me(n,e,t,r){if(!n.map)return De(n.source,e,t,r,n.content,n.ignore);const s=Nt(n.map,e,t);return s==null?null:s.length===1?we:Me(n.sources[s[1]],s[2],s[3],s.length===5?n.map.names[s[4]]:r)}c(Me,"originalPositionFor");function Vt(n){return Array.isArray(n)?n:[n]}c(Vt,"asArray");function Jt(n,e){const t=Vt(n).map(o=>new Se(o,"")),r=t.pop();for(let o=0;o<t.length;o++)if(t[o].sources.length>1)throw new Error(`Transformation map ${o} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);let s=Fe(r,e,"",0);for(let o=t.length-1;o>=0;o--)s=Ie(t[o],[s]);return s}c(Jt,"buildSourceMapTree");function Fe(n,e,t,r){const{resolvedSources:s,sourcesContent:o,ignoreList:a}=n,u=r+1,m=s.map((f,d)=>{const h={importer:t,depth:u,source:f||"",content:void 0,ignore:void 0},l=e(h.source,h),{source:y}=h;if(l)return Fe(new Se(l,y),e,y,u);const x=o?o[d]:null,S=a?a.includes(d):!1;return Kt(y,x,S)});return Ie(n,m)}c(Fe,"build");var Wt=class{static{c(this,"SourceMap")}constructor(n,e){const t=e.decodedMappings?Te(n):Pt(n);this.version=t.version,this.file=t.file,this.mappings=t.mappings,this.names=t.names,this.ignoreList=t.ignoreList,this.sourceRoot=t.sourceRoot,this.sources=t.sources,e.excludeContent||(this.sourcesContent=t.sourcesContent)}toString(){return JSON.stringify(this)}};function Gt(n,e,t){const r={excludeContent:!1,decodedMappings:!1},s=Jt(n,e);return new Wt(zt(s),r)}c(Gt,"remapping");function qt(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}c(qt,"getDefaultExportFromCjs");var H={},Oe;function Ht(){return Oe||(Oe=1,(function(n){Object.defineProperty(n,"commentRegex",{get:c(function(){return/^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg},"getCommentRegex")}),Object.defineProperty(n,"mapFileCommentRegex",{get:c(function(){return/(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg},"getMapFileCommentRegex")});var e;typeof Buffer<"u"?typeof Buffer.from=="function"?e=t:e=r:e=s;function t(l){return Buffer.from(l,"base64").toString()}c(t,"decodeBase64WithBufferFrom");function r(l){if(typeof value=="number")throw new TypeError("The value to decode must not be of type number.");return new Buffer(l,"base64").toString()}c(r,"decodeBase64WithNewBuffer");function s(l){return decodeURIComponent(escape(atob(l)))}c(s,"decodeBase64WithAtob");function o(l){return l.split(",").pop()}c(o,"stripComment");function a(l,y){var x=n.mapFileCommentRegex.exec(l),S=x[1]||x[2];try{var l=y(S);return l!=null&&typeof l.catch=="function"?l.catch(v):l}catch(p){v(p)}function v(p){throw new Error("An error occurred while trying to read the map file at "+S+`
`+p.stack)}c(v,"throwError")}c(a,"readFromFileMap");function u(l,y){y=y||{},y.hasComment&&(l=o(l)),y.encoding==="base64"?l=e(l):y.encoding==="uri"&&(l=decodeURIComponent(l)),(y.isJSON||y.encoding)&&(l=JSON.parse(l)),this.sourcemap=l}c(u,"Converter"),u.prototype.toJSON=function(l){return JSON.stringify(this.sourcemap,null,l)},typeof Buffer<"u"?typeof Buffer.from=="function"?u.prototype.toBase64=m:u.prototype.toBase64=f:u.prototype.toBase64=d;function m(){var l=this.toJSON();return Buffer.from(l,"utf8").toString("base64")}c(m,"encodeBase64WithBufferFrom");function f(){var l=this.toJSON();if(typeof l=="number")throw new TypeError("The json to encode must not be of type number.");return new Buffer(l,"utf8").toString("base64")}c(f,"encodeBase64WithNewBuffer");function d(){var l=this.toJSON();return btoa(unescape(encodeURIComponent(l)))}c(d,"encodeBase64WithBtoa"),u.prototype.toURI=function(){var l=this.toJSON();return encodeURIComponent(l)},u.prototype.toComment=function(l){var y,x,S;return l!=null&&l.encoding==="uri"?(y="",x=this.toURI()):(y=";base64",x=this.toBase64()),S="sourceMappingURL=data:application/json;charset=utf-8"+y+","+x,l!=null&&l.multiline?"/*# "+S+" */":"//# "+S},u.prototype.toObject=function(){return JSON.parse(this.toJSON())},u.prototype.addProperty=function(l,y){if(this.sourcemap.hasOwnProperty(l))throw new Error('property "'+l+'" already exists on the sourcemap, use set property instead');return this.setProperty(l,y)},u.prototype.setProperty=function(l,y){return this.sourcemap[l]=y,this},u.prototype.getProperty=function(l){return this.sourcemap[l]},n.fromObject=function(l){return new u(l)},n.fromJSON=function(l){return new u(l,{isJSON:!0})},n.fromURI=function(l){return new u(l,{encoding:"uri"})},n.fromBase64=function(l){return new u(l,{encoding:"base64"})},n.fromComment=function(l){var y,x;return l=l.replace(/^\/\*/g,"//").replace(/\*\/$/g,""),y=n.commentRegex.exec(l),x=y&&y[4]||"uri",new u(l,{encoding:x,hasComment:!0})};function h(l){return new u(l,{isJSON:!0})}c(h,"makeConverter"),n.fromMapFileComment=function(l,y){if(typeof y=="string")throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var x=a(l,y);return x!=null&&typeof x.then=="function"?x.then(h):h(x)},n.fromSource=function(l){var y=l.match(n.commentRegex);return y?n.fromComment(y.pop()):null},n.fromMapFileSource=function(l,y){if(typeof y=="string")throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");var x=l.match(n.mapFileCommentRegex);return x?n.fromMapFileComment(x.pop(),y):null},n.removeComments=function(l){return l.replace(n.commentRegex,"")},n.removeMapFileComments=function(l){return l.replace(n.mapFileCommentRegex,"")},n.generateMapFileComment=function(l,y){var x="sourceMappingURL="+l;return y&&y.multiline?"/*# "+x+" */":"//# "+x}})(H)),H}c(Ht,"requireConvertSourceMap");var Xt=Ht(),Re=qt(Xt);function Qt(n){return{...n,compilerOptions:n.compilerOptions??{},respectExternal:n.respectExternal??!1,includeExternal:n.includeExternal??[],sourcemap:n.sourcemap??!1}}c(Qt,"resolveDefaultOptions");const _=/\.d\.(c|m)?tsx?$/,X=/\.json$/,Ae=/((\.d)?\.(c|m)?(t|j)sx?|\.json)$/;function Q(n){return n.replace(Ae,"")}c(Q,"trimExtension");function Pe(n){return n.replace(Ae,".d.ts")}c(Pe,"getDeclarationId");function U(n,e){return i.createSourceFile(n,e,i.ScriptTarget.Latest,!0)}c(U,"parse");const Y={getCurrentDirectory:c(()=>i.sys.getCurrentDirectory(),"getCurrentDirectory"),getNewLine:c(()=>i.sys.newLine,"getNewLine"),getCanonicalFileName:i.sys.useCaseSensitiveFileNames?n=>n:n=>n.toLowerCase()},Yt={declaration:!0,noEmit:!1,emitDeclarationOnly:!0,noEmitOnError:!0,checkJs:!1,declarationMap:!1,skipLibCheck:!0,preserveSymlinks:!0,target:i.ScriptTarget.ESNext,resolveJsonModule:!0},K=new Map,$=c((...n)=>process.env.DTS_LOG_CACHE?console.log("[cache]",...n):null,"logCache");function Le([n,e],t){for($(n),K.set(n,t);n!==e&&n!==N.dirname(n);){if(n=N.dirname(n),$("up",n),K.has(n))return $("has",n);K.set(n,t)}}c(Le,"cacheConfig");function Z(n,e,t,r){const s={...Yt,...e,...r===!0&&{declarationMap:!0}};let o=N.dirname(n),a=[];const u=t||o;if(K.has(u))$("HIT",u);else{$("miss",u);const h=t?N.resolve(process.cwd(),t):i.findConfigFile(o,i.sys.fileExists);if(!h)return{dtsFiles:a,dirName:o,compilerOptions:s};const l=o;o=N.dirname(h);const{config:y,error:x}=i.readConfigFile(h,i.sys.readFile);if(x)return console.error(i.formatDiagnostic(x,Y)),{dtsFiles:a,dirName:o,compilerOptions:s};$("tsconfig",y);const S=i.parseJsonConfigFileContent(y,i.sys,o);Le(t?[t,t]:[l,o],S)}const{fileNames:m,options:f,errors:d}=K.get(u);return a=m.filter(h=>_.test(h)),d.length?(console.error(i.formatDiagnostics(d,Y)),{dtsFiles:a,dirName:o,compilerOptions:s}):{dtsFiles:a,dirName:o,compilerOptions:{...f,...s}}}c(Z,"getCompilerOptions");function Zt(n,e,t,r){const{dtsFiles:s,compilerOptions:o}=Z(n,e,t,r);return i.createProgram([n].concat(Array.from(s)),o,i.createCompilerHost(o,!0))}c(Zt,"createProgram$1");function en(n,e,t,r){const s=[],o=new Set;let a=[],u="",m={};for(let f of n){if(_.test(f))continue;f=N.resolve(f);const d=Z(f,e,t,r);if(d.dtsFiles.forEach(o.add,o),!a.length){a.push(f),{dirName:u,compilerOptions:m}=d;continue}if(d.dirName===u)a.push(f);else{const h=i.createCompilerHost(m,!0),l=i.createProgram(a.concat(Array.from(o)),m,h);s.push(l),a=[f],{dirName:u,compilerOptions:m}=d}}if(a.length){const f=i.createCompilerHost(m,!0),d=i.createProgram(a.concat(Array.from(o)),m,f);s.push(d)}return s}c(en,"createPrograms");function tn(){let n;try{return{codeFrameColumns:n}=qe("@babel/code-frame"),n}catch{try{return{codeFrameColumns:n}=He(import.meta.url)("@babel/code-frame"),n}catch{}}}c(tn,"getCodeFrame");function nn(n){const e=n.getSourceFile(),t=e.getLineAndCharacterOfPosition(n.getStart()),r=e.getLineAndCharacterOfPosition(n.getEnd());return{start:{line:t.line+1,column:t.character+1},end:{line:r.line+1,column:r.character+1}}}c(nn,"getLocation");function rn(n){const e=tn(),r=n.getSourceFile().getFullText(),s=nn(n);return e?`
`+e(r,s,{highlightCode:!0}):`
${s.start.line}:${s.start.column}: \`${n.getFullText().trim()}\``}c(rn,"frameNode");class w extends Error{static{c(this,"UnsupportedSyntaxError")}constructor(e,t="Syntax not yet supported"){super(`${t}
${rn(e)}`)}}class sn{static{c(this,"NamespaceFixer")}constructor(e){this.sourceFile=e}findNamespaces(){const e=[],t={};for(const r of this.sourceFile.statements){const s={start:r.getStart(),end:r.getEnd()};if(i.isEmptyStatement(r)){e.unshift({name:"",exports:[],location:s});continue}if((i.isImportDeclaration(r)||i.isExportDeclaration(r))&&r.moduleSpecifier&&i.isStringLiteral(r.moduleSpecifier)){const{text:d}=r.moduleSpecifier;if(d.startsWith(".")&&(d.endsWith(".d.ts")||d.endsWith(".d.cts")||d.endsWith(".d.mts"))){const h=r.moduleSpecifier.getStart()+1,l=r.moduleSpecifier.getEnd()-1;e.unshift({name:"",exports:[],location:{start:h,end:l},textBeforeCodeAfter:d.replace(/\.d\.ts$/,".js").replace(/\.d\.cts$/,".cjs").replace(/\.d\.mts$/,".mjs")})}}if(i.isModuleDeclaration(r)&&r.body&&i.isModuleBlock(r.body)){for(const d of r.body.statements)if(i.isExportDeclaration(d)&&d.exportClause){if(i.isNamespaceExport(d.exportClause))continue;for(const h of d.exportClause.elements)h.propertyName&&h.propertyName.getText()==h.name.getText()&&e.unshift({name:"",exports:[],location:{start:h.propertyName.getEnd(),end:h.name.getEnd()}})}}if(i.isClassDeclaration(r)?t[r.name.getText()]={type:"class",generics:r.typeParameters}:i.isFunctionDeclaration(r)?t[r.name.getText()]={type:"function"}:i.isInterfaceDeclaration(r)?t[r.name.getText()]={type:"interface",generics:r.typeParameters}:i.isTypeAliasDeclaration(r)?t[r.name.getText()]={type:"type",generics:r.typeParameters}:i.isModuleDeclaration(r)&&i.isIdentifier(r.name)?t[r.name.getText()]={type:"namespace"}:i.isEnumDeclaration(r)&&(t[r.name.getText()]={type:"enum"}),!i.isVariableStatement(r))continue;const{declarations:o}=r.declarationList;if(o.length!==1)continue;const a=o[0],u=a.name.getText();if(!a.initializer||!i.isCallExpression(a.initializer)){t[u]={type:"var"};continue}const m=a.initializer.arguments[0];if(!a.initializer.expression.getFullText().includes("/*#__PURE__*/Object.freeze")||!i.isObjectLiteralExpression(m))continue;const f=[];for(const d of m.properties){if(!i.isPropertyAssignment(d)||!(i.isIdentifier(d.name)||i.isStringLiteral(d.name))||d.name.text!=="__proto__"&&!i.isIdentifier(d.initializer))throw new w(d,"Expected a property assignment");d.name.text!=="__proto__"&&f.push({exportedName:d.name.text,localName:d.initializer.getText()})}e.unshift({name:u,exports:f,location:s})}return{namespaces:e,itemTypes:t}}fix(){let e=this.sourceFile.getFullText();const{namespaces:t,itemTypes:r}=this.findNamespaces();for(const s of t){const o=e.slice(s.location.end);e=e.slice(0,s.location.start);for(const{exportedName:a,localName:u}of s.exports)if(a===u){const{type:m,generics:f}=r[u]||{};if(m==="interface"||m==="type"){const d=_e(f);e+=`type ${s.name}_${a}${d.in} = ${u}${d.out};
`}else if(m==="enum"||m==="class"){const d=_e(f);e+=`type ${s.name}_${a}${d.in} = ${u}${d.out};
`,e+=`declare const ${s.name}_${a}: typeof ${u};
`}else m==="namespace"?e+=`import ${s.name}_${a} = ${u};
`:e+=`declare const ${s.name}_${a}: typeof ${u};
`}if(s.name){e+=`declare namespace ${s.name} {
`,e+=`  export {
`;for(const{exportedName:a,localName:u}of s.exports)a===u?e+=`    ${s.name}_${a} as ${a},
`:e+=`    ${u} as ${a},
`;e+=`  };
`,e+="}"}e+=s.textBeforeCodeAfter??"",e+=o}return e}}function _e(n){return!n||!n.length?{in:"",out:""}:{in:`<${n.map(e=>e.getText()).join(", ")}>`,out:`<${n.map(e=>e.name.getText()).join(", ")}>`}}c(_e,"renderTypeParams");let $e=1;function on(n){return b({type:"Program",sourceType:"module",body:[]},{start:n.getFullStart(),end:n.getEnd()})}c(on,"createProgram");function an(n){const e={type:"Identifier",name:String($e++)};return{ident:e,expr:{type:"AssignmentPattern",left:e,right:n}}}c(an,"createReference");function M(n){return b({type:"Identifier",name:n.getText()},n)}c(M,"createIdentifier");function cn(n){const e=b({type:"FunctionExpression",id:null,params:[],body:{type:"BlockStatement",body:[]}},n),t=b({type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"Identifier",name:String($e++)},arguments:[e],optional:!1}},n);return{fn:e,iife:t}}c(cn,"createIIFE");function ln(){const n={type:"ArrayExpression",elements:[]};return{expr:n,stmt:{type:"ReturnStatement",argument:n}}}c(ln,"createReturn");function un(n,e){return b({type:"FunctionDeclaration",id:b({type:"Identifier",name:i.idText(n)},n),params:[],body:{type:"BlockStatement",body:[]}},e)}c(un,"createDeclaration");function A(n){if(i.isLiteralExpression(n))return{type:"Literal",value:n.text};if(i.isPropertyAccessExpression(n)){if(i.isPrivateIdentifier(n.name))throw new w(n.name);return b({type:"MemberExpression",computed:!1,optional:!1,object:A(n.expression),property:A(n.name)},{start:n.expression.getStart(),end:n.name.getEnd()})}if(i.isObjectLiteralExpression(n))return b({type:"ObjectExpression",properties:n.properties.map(e=>{if(i.isPropertyAssignment(e))return b({type:"Property",key:i.isIdentifier(e.name)?M(e.name):A(e.name),value:A(e.initializer),kind:"init",method:!1,shorthand:!1,computed:i.isComputedPropertyName(e.name)},e);if(i.isShorthandPropertyAssignment(e))return b({type:"Property",key:M(e.name),value:M(e.name),kind:"init",method:!1,shorthand:!0,computed:!1},e);throw new w(e,"Unsupported property type in object literal")})},n);if(i.isArrayLiteralExpression(n))return b({type:"ArrayExpression",elements:n.elements.map(e=>{if(i.isExpression(e))return A(e);throw new w(e,"Unsupported element type in array literal")})},n);if(i.isIdentifier(n))return M(n);if(n.kind==i.SyntaxKind.NullKeyword)return{type:"Literal",value:null};throw new w(n)}c(A,"convertExpression");function b(n,e){const t="start"in e?e:{start:e.getStart(),end:e.getEnd()};return Object.assign(n,t)}c(b,"withStartEnd");function z(n,e){return(i.getCombinedModifierFlags(n)&e)===e}c(z,"matchesModifier");class pn{static{c(this,"LanguageService")}constructor(e){this.fileName="index.d.ts";const t={getCompilationSettings:c(()=>({noEmit:!0,noResolve:!0,skipLibCheck:!0,declaration:!1,checkJs:!1,declarationMap:!1,target:i.ScriptTarget.ESNext}),"getCompilationSettings"),getScriptFileNames:c(()=>[this.fileName],"getScriptFileNames"),getScriptVersion:c(()=>"1","getScriptVersion"),getScriptSnapshot:c(r=>r===this.fileName?i.ScriptSnapshot.fromString(e):void 0,"getScriptSnapshot"),getCurrentDirectory:c(()=>"","getCurrentDirectory"),getDefaultLibFileName:c(()=>"","getDefaultLibFileName"),fileExists:c(r=>r===this.fileName,"fileExists"),readFile:c(r=>r===this.fileName?e:void 0,"readFile")};this.service=i.createLanguageService(t,i.createDocumentRegistry(void 0,""),i.LanguageServiceMode.PartialSemantic)}findReferenceCount(e){const t=this.service.findReferences(this.fileName,e.getStart());return t?.length?t.reduce((r,s)=>r+s.references.length,0):0}}class fn{static{c(this,"TypeOnlyFixer")}constructor(e,t){this.DEBUG=!!process.env.DTS_EXPORTS_FIXER_DEBUG,this.types=new Set,this.values=new Set,this.typeHints=new Map,this.reExportTypeHints=new Map,this.importNodes=[],this.exportNodes=[],this.rawCode=t,this.source=U(e,t),this.code=new W(t)}fix(){return this.analyze(this.source.statements),(this.typeHints.size||this.reExportTypeHints.size)&&(this.service=new pn(this.rawCode),this.importNodes.forEach(e=>this.fixTypeOnlyImport(e))),this.types.size&&this.exportNodes.forEach(e=>this.fixTypeOnlyExport(e)),this.types.size?{magicCode:this.code}:{code:this.rawCode,map:null}}fixTypeOnlyImport(e){let t=!1;const r=[],s=[],o=e.moduleSpecifier.getText(),a=e.importClause.name,u=e.importClause.namedBindings;if(a){const m=a.text;this.isTypeOnly(m)?this.isUselessImport(a)?t=!0:r.push(`import type ${m} from ${o};`):s.push(`import ${m} from ${o};`)}if(u&&i.isNamespaceImport(u)){const m=u.name.text;this.isTypeOnly(m)?this.isUselessImport(u.name)?t=!0:r.push(`import type * as ${m} from ${o};`):s.push(`import * as ${m} from ${o};`)}if(u&&i.isNamedImports(u)){const m=[],f=[];for(const d of u.elements)this.isTypeOnly(d.name.text)?this.isUselessImport(d.name)?t=!0:m.push(d.getText()):f.push(d.getText());m.length&&r.push(`import type { ${m.join(", ")} } from ${o};`),f.length&&s.push(`import { ${f.join(", ")} } from ${o};`)}(r.length||t)&&this.code.overwrite(e.getStart(),e.getEnd(),[...s,...r].join(`
${Be(e)}`))}fixTypeOnlyExport(e){const t=[],r=[],s=e.moduleSpecifier?.getText();if(i.isNamespaceExport(e.exportClause)){const o=e.exportClause.name.text;this.isReExportTypeOnly(o)?t.push(`export type * as ${o} from ${s};`):r.push(`export * as ${o} from ${s};`)}if(i.isNamedExports(e.exportClause)){const o=[],a=[];for(const u of e.exportClause.elements){const m=u.propertyName?.text||u.name.text;(e.moduleSpecifier?this.isReExportTypeOnly(u.name.text):this.isTypeOnly(m))?o.push(u.getText()):a.push(u.getText())}o.length&&t.push(`export type { ${o.join(", ")} }${s?` from ${s}`:""};`),a.length&&r.push(`export { ${a.join(", ")} }${s?` from ${s}`:""};`)}t.length&&this.code.overwrite(e.getStart(),e.getEnd(),[...r,...t].join(`
${Be(e)}`))}analyze(e){for(const t of e){if(this.DEBUG&&console.log(t.getText(),t.kind),i.isImportDeclaration(t)&&t.importClause){this.importNodes.push(t);continue}if(i.isExportDeclaration(t)&&t.exportClause){this.exportNodes.push(t);continue}if(i.isInterfaceDeclaration(t)){this.DEBUG&&console.log(`${t.name.getFullText()} is a type`),this.types.add(t.name.text);continue}if(i.isTypeAliasDeclaration(t)){const r=t.name.text;this.DEBUG&&console.log(`${t.name.getFullText()} is a type`),this.types.add(r);continue}if(i.isEnumDeclaration(t)||i.isFunctionDeclaration(t)||i.isClassDeclaration(t)||i.isVariableStatement(t)){if(i.isVariableStatement(t))for(const r of t.declarationList.declarations)i.isIdentifier(r.name)&&(this.DEBUG&&console.log(`${r.name.getFullText()} is a value (from var statement)`),this.values.add(r.name.text));else t.name&&(this.DEBUG&&console.log(`${t.name.getFullText()} is a value (from declaration)`),this.values.add(t.name.text));continue}if(i.isModuleBlock(t)){this.analyze(t.statements);continue}if(i.isModuleDeclaration(t)){t.name&&i.isIdentifier(t.name)&&(this.DEBUG&&console.log(`${t.name.getFullText()} is a value (from module declaration)`),this.values.add(t.name.text)),this.analyze(t.getChildren());continue}this.DEBUG&&console.log("unhandled statement",t.getFullText(),t.kind)}}isUselessImport(e){const t=this.service.findReferenceCount(e),r=this.typeHints.get(e.text);return r&&r+1>=t}isTypeOnly(e){return this.typeHints.has(e)||this.types.has(e)&&!this.values.has(e)}isReExportTypeOnly(e){return this.reExportTypeHints.has(e)}}function Be(n){const e=n.getFullText().match(/^(?:\n*)([ ]*)/);return" ".repeat(e?.[1]?.length||0)}c(Be,"getNodeIndent");function je(n,e,t){for(const r of n.statements)ee(e,r),i.isModuleDeclaration(r)&&r.body&&i.isModuleBlock(r.body)&&je(r.body,e)}c(je,"preProcessNamespaceBody");function mn({sourceFile:n,isEntry:e,isJSON:t}){const r=new W(n.getFullText()),s=!e&&dn(n),o=new Set,a=new Set;let u="";const m=new Map,f=new Map;for(const p of n.statements){if(i.isEmptyStatement(p)){r.remove(p.getStart(),p.getEnd());continue}if(i.isImportDeclaration(p)){if(!p.importClause)continue;p.importClause.name&&o.add(p.importClause.name.text),p.importClause.namedBindings&&(i.isNamespaceImport(p.importClause.namedBindings)?o.add(p.importClause.namedBindings.name.text):p.importClause.namedBindings.elements.forEach(g=>o.add(g.name.text)))}else if(i.isEnumDeclaration(p)||i.isFunctionDeclaration(p)||i.isInterfaceDeclaration(p)||i.isClassDeclaration(p)||i.isTypeAliasDeclaration(p)||i.isModuleDeclaration(p)){if(p.name){const g=p.name.getText();o.add(g),z(p,i.ModifierFlags.ExportDefault)?u=g:(s&&i.isIdentifier(p.name)||z(p,i.ModifierFlags.Export))&&a.add(g),p.flags&i.NodeFlags.GlobalAugmentation||v(g,[te(p),ke(p)])}i.isModuleDeclaration(p)&&(p.body&&i.isModuleBlock(p.body)&&je(p.body,r),hn(r,p)),ee(r,p)}else if(i.isVariableStatement(p)){const{declarations:g}=p.declarationList,E=z(p,i.ModifierFlags.Export);for(const D of p.declarationList.declarations)if(i.isIdentifier(D.name)){const R=D.name.getText();o.add(R),(s||E)&&a.add(R)}if(ee(r,p),g.length===1){const D=g[0];i.isIdentifier(D.name)&&v(D.name.getText(),[te(p),ke(p)])}else{const D=g.slice(),R=D.shift();v(R.name.getText(),[te(p),R.getEnd()]);for(const P of D)i.isIdentifier(P.name)&&v(P.name.getText(),[P.getFullStart(),P.getEnd()])}const{flags:T}=p.declarationList,C=`declare ${T&i.NodeFlags.Let?"let":T&i.NodeFlags.Const?"const":"var"} `,I=p.declarationList.getChildren().find(D=>D.kind===i.SyntaxKind.SyntaxList).getChildren();let F=0;for(const D of I)if(D.kind===i.SyntaxKind.CommaToken)F=D.getStart(),r.remove(F,D.getEnd());else if(F){r.appendLeft(F,`;
`);const R=D.getFullStart(),P=r.slice(R,D.getStart()),re=P.length-P.trimStart().length;re?r.overwrite(R,R+re,C):r.appendLeft(R,C)}}}for(const p of n.statements){if(y(p),i.isExportAssignment(p)&&!p.isExportEquals&&(i.isObjectLiteralExpression(p.expression)||i.isArrayLiteralExpression(p.expression))){u||(u=S("export_default")),r.overwrite(p.getStart(),p.expression.getStart(),`declare var ${u} = `);continue}if(z(p,i.ModifierFlags.ExportDefault)&&(i.isFunctionDeclaration(p)||i.isClassDeclaration(p))){if(p.name)continue;u||(u=S("export_default"));const g=p.getChildren(),E=g.findIndex(I=>I.kind===i.SyntaxKind.ClassKeyword||I.kind===i.SyntaxKind.FunctionKeyword),T=g[E],O=g[E+1];if(O.kind>=i.SyntaxKind.FirstPunctuation&&O.kind<=i.SyntaxKind.LastPunctuation){const I=r.slice(T.getEnd(),O.getStart())!=" ";r.appendLeft(O.getStart(),`${I?" ":""}${u}`)}else r.appendRight(T.getEnd(),` ${u}`)}}for(const p of f.values()){const E=p.pop()[0];for(const T of p)r.move(T[0],T[1],E)}u&&r.append(`
export default ${u};
`),a.size&&r.append(`
export { ${[...a].join(", ")} };
`),t&&a.size&&(u=S("export_default"),r.append([`
declare const ${u}: {`,[...a].map(p=>`  ${p}: typeof ${p};`).join(`
`),"};",`export default ${u};
`].join(`
`)));for(const[p,g]of m.entries())r.prepend(`import * as ${g} from "${p}";
`);const d=n.getLineStarts(),h=new Set;for(const p of n.typeReferenceDirectives){h.add(p.fileName);const{line:g}=n.getLineAndCharacterOfPosition(p.pos),E=d[g];let T=n.getLineEndOfPosition(p.pos);r.slice(T,T+1)===`
`&&(T+=1),r.remove(E,T)}const l=new Set;for(const p of n.referencedFiles){l.add(p.fileName);const{line:g}=n.getLineAndCharacterOfPosition(p.pos),E=d[g];let T=n.getLineEndOfPosition(p.pos);r.slice(T,T+1)===`
`&&(T+=1),r.remove(E,T)}return{code:r,typeReferences:h,fileReferences:l};function y(p){if(i.forEachChild(p,y),i.isImportTypeNode(p)){if(!i.isLiteralTypeNode(p.argument)||!i.isStringLiteral(p.argument.literal))throw new w(p,"inline imports should have a literal argument");const g=p.argument.literal.text,E=p.getChildren(),T=E.find(F=>F.kind===i.SyntaxKind.ImportKeyword).getStart();let O=p.getEnd();const C=E.find(F=>F.kind===i.SyntaxKind.DotToken||F.kind===i.SyntaxKind.LessThanToken);C&&(O=C.getStart());const I=x(g);r.overwrite(T,O,I)}}function x(p){let g=m.get(p);return g||(g=S(yn(p)),m.set(p,g)),g}function S(p){let g=p;for(;o.has(g);)g=`_${g}`;return o.add(g),g}function v(p,g){let E=f.get(p);if(!E)E=[g],f.set(p,E);else{const T=E[E.length-1];T[1]===g[0]?T[1]=g[1]:E.push(g)}}}c(mn,"preProcess");function dn(n){let e=!1;for(const t of n.statements){if(i.isExportDeclaration(t)||i.isExportAssignment(t))return!1;(e||i.isImportDeclaration(t)||z(t,i.ModifierFlags.Export))&&(e=!0)}return e}c(dn,"isGlobalModule");function ee(n,e){if(!i.canHaveModifiers(e))return;if(e.parent.kind===i.SyntaxKind.SourceFile){let r=!1;const s=i.isEnumDeclaration(e)||i.isClassDeclaration(e)||i.isFunctionDeclaration(e)||i.isModuleDeclaration(e)||i.isVariableStatement(e);for(const o of e.modifiers??[])switch(o.kind){case i.SyntaxKind.ExportKeyword:case i.SyntaxKind.DefaultKeyword:n.remove(o.getStart(),o.getEnd()+1);break;case i.SyntaxKind.DeclareKeyword:r=!0}s&&!r&&n.appendRight(e.getStart(),"declare ")}}c(ee,"fixModifiers");function hn(n,e){if(!(!e.body||!i.isModuleBlock(e.body))){for(const t of e.body.statements)if(i.isExportDeclaration(t)&&t.exportClause){if(i.isNamespaceExport(t.exportClause))continue;for(const r of t.exportClause.elements)r.propertyName||n.appendLeft(r.name.getEnd(),` as ${r.name.getText()}`)}}}c(hn,"duplicateExports");function yn(n){return n.replace(/[^a-zA-Z0-9_$]/g,()=>"_")}c(yn,"getSafeName");function te(n){const e=n.getFullStart();return e+(Ue(n,e)?1:0)}c(te,"getStart");function ke(n){const e=n.getEnd();return e+(Ue(n,e)?1:0)}c(ke,"getEnd");function Ue(n,e){return n.getSourceFile().getFullText()[e]===`
`}c(Ue,"newlineAt");const gn=new Set([i.SyntaxKind.LiteralType,i.SyntaxKind.VoidKeyword,i.SyntaxKind.UnknownKeyword,i.SyntaxKind.AnyKeyword,i.SyntaxKind.BooleanKeyword,i.SyntaxKind.NumberKeyword,i.SyntaxKind.StringKeyword,i.SyntaxKind.ObjectKeyword,i.SyntaxKind.NullKeyword,i.SyntaxKind.UndefinedKeyword,i.SyntaxKind.SymbolKeyword,i.SyntaxKind.NeverKeyword,i.SyntaxKind.ThisKeyword,i.SyntaxKind.ThisType,i.SyntaxKind.BigIntKeyword]);class Ke{static{c(this,"DeclarationScope")}constructor({id:e,range:t}){if(this.scopes=[],e)this.declaration=un(e,t);else{const{iife:s,fn:o}=cn(t);this.iife=s,this.declaration=o}const r=ln();this.declaration.body.body.push(r.stmt),this.returnExpr=r.expr}pushScope(){this.scopes.push(new Set)}popScope(e=1){for(let t=0;t<e;t++)this.scopes.pop()}pushTypeVariable(e){const t=e.getText();this.scopes[this.scopes.length-1]?.add(t)}pushReference(e){let t;if(e.type==="Identifier"?t=e.name:e.type==="MemberExpression"&&e.object.type==="Identifier"&&(t=e.object.name),t){for(const o of this.scopes)if(o.has(t))return}if(t==="this")return;const{ident:r,expr:s}=an(e);this.declaration.params.push(s),this.returnExpr.elements.push(r)}pushIdentifierReference(e){this.pushReference(M(e))}convertEntityName(e){return i.isIdentifier(e)?M(e):b({type:"MemberExpression",computed:!1,optional:!1,object:this.convertEntityName(e.left),property:M(e.right)},e)}convertPropertyAccess(e){if(!i.isIdentifier(e.expression)&&!i.isPropertyAccessExpression(e.expression))throw new w(e.expression);if(i.isPrivateIdentifier(e.name))throw new w(e.name);const t=i.isIdentifier(e.expression)?M(e.expression):this.convertPropertyAccess(e.expression);return b({type:"MemberExpression",computed:!1,optional:!1,object:t,property:M(e.name)},e)}convertComputedPropertyName(e){if(!e.name||!i.isComputedPropertyName(e.name))return;const{expression:t}=e.name;if(!(i.isLiteralExpression(t)||i.isPrefixUnaryExpression(t))){if(i.isIdentifier(t))return this.pushReference(M(t));if(i.isPropertyAccessExpression(t))return this.pushReference(this.convertPropertyAccess(t));throw new w(t)}}convertParametersAndType(e){this.convertComputedPropertyName(e);const t=this.convertTypeParameters(e.typeParameters);for(const r of e.parameters)this.convertTypeNode(r.type);this.convertTypeNode(e.type),this.popScope(t)}convertHeritageClauses(e){for(const t of e.heritageClauses||[])for(const r of t.types)this.pushReference(A(r.expression)),this.convertTypeArguments(r)}convertTypeArguments(e){if(e.typeArguments)for(const t of e.typeArguments)this.convertTypeNode(t)}convertMembers(e){for(const t of e){if(i.isPropertyDeclaration(t)||i.isPropertySignature(t)||i.isIndexSignatureDeclaration(t)){i.isPropertyDeclaration(t)&&t.initializer&&i.isPropertyAccessExpression(t.initializer)&&this.pushReference(this.convertPropertyAccess(t.initializer)),this.convertComputedPropertyName(t),this.convertTypeNode(t.type);continue}if(i.isMethodDeclaration(t)||i.isMethodSignature(t)||i.isConstructorDeclaration(t)||i.isConstructSignatureDeclaration(t)||i.isCallSignatureDeclaration(t)||i.isGetAccessorDeclaration(t)||i.isSetAccessorDeclaration(t))this.convertParametersAndType(t);else throw new w(t)}}convertTypeParameters(e){if(!e)return 0;for(const t of e)this.convertTypeNode(t.constraint),this.convertTypeNode(t.default),this.pushScope(),this.pushTypeVariable(t.name);return e.length}convertTypeNode(e){if(e&&!gn.has(e.kind)){if(i.isTypeReferenceNode(e)){this.pushReference(this.convertEntityName(e.typeName)),this.convertTypeArguments(e);return}if(i.isTypeLiteralNode(e)){this.convertMembers(e.members);return}if(i.isArrayTypeNode(e)){this.convertTypeNode(e.elementType);return}if(i.isTupleTypeNode(e)){for(const t of e.elements)this.convertTypeNode(t);return}if(i.isNamedTupleMember(e)||i.isParenthesizedTypeNode(e)||i.isTypeOperatorNode(e)||i.isTypePredicateNode(e)){this.convertTypeNode(e.type);return}if(i.isUnionTypeNode(e)||i.isIntersectionTypeNode(e)){for(const t of e.types)this.convertTypeNode(t);return}if(i.isMappedTypeNode(e)){const{typeParameter:t,type:r,nameType:s}=e;this.convertTypeNode(t.constraint),this.pushScope(),this.pushTypeVariable(t.name),this.convertTypeNode(r),s&&this.convertTypeNode(s),this.popScope();return}if(i.isConditionalTypeNode(e)){this.convertTypeNode(e.checkType),this.pushScope(),this.convertTypeNode(e.extendsType),this.convertTypeNode(e.trueType),this.convertTypeNode(e.falseType),this.popScope();return}if(i.isIndexedAccessTypeNode(e)){this.convertTypeNode(e.objectType),this.convertTypeNode(e.indexType);return}if(i.isFunctionOrConstructorTypeNode(e)){this.convertParametersAndType(e);return}if(i.isTypeQueryNode(e)){const t=this.convertEntityName(e.exprName);this.pushReference(t),this.convertTypeArguments(e);return}if(i.isRestTypeNode(e)){this.convertTypeNode(e.type);return}if(i.isOptionalTypeNode(e)){this.convertTypeNode(e.type);return}if(i.isTemplateLiteralTypeNode(e)){for(const t of e.templateSpans)this.convertTypeNode(t.type);return}if(i.isInferTypeNode(e)){const{typeParameter:t}=e;this.convertTypeNode(t.constraint),this.pushTypeVariable(t.name);return}else throw new w(e)}}convertNamespace(e,t=!1){if(this.pushScope(),t&&e.body&&i.isModuleDeclaration(e.body)){this.convertNamespace(e.body,!0);return}if(!e.body||!i.isModuleBlock(e.body))throw new w(e,'namespace must have a "ModuleBlock" body.');const{statements:r}=e.body;for(const s of r){if(i.isEnumDeclaration(s)||i.isFunctionDeclaration(s)||i.isClassDeclaration(s)||i.isInterfaceDeclaration(s)||i.isTypeAliasDeclaration(s)||i.isModuleDeclaration(s)){if(s.name&&i.isIdentifier(s.name))this.pushTypeVariable(s.name);else throw new w(s,"non-Identifier name not supported");continue}if(i.isVariableStatement(s)){for(const o of s.declarationList.declarations)if(i.isIdentifier(o.name))this.pushTypeVariable(o.name);else throw new w(o,"non-Identifier name not supported");continue}if(i.isImportDeclaration(s)){if(s.importClause&&(s.importClause.name&&this.pushTypeVariable(s.importClause.name),s.importClause.namedBindings))if(i.isNamespaceImport(s.importClause.namedBindings))this.pushTypeVariable(s.importClause.namedBindings.name);else for(const o of s.importClause.namedBindings.elements)this.pushTypeVariable(o.name);continue}if(i.isImportEqualsDeclaration(s)){this.pushTypeVariable(s.name);continue}if(!i.isExportDeclaration(s))throw new w(s,"namespace child (hoisting) not supported yet")}for(const s of r){if(i.isVariableStatement(s)){for(const o of s.declarationList.declarations)o.type&&this.convertTypeNode(o.type);continue}if(i.isFunctionDeclaration(s)){this.convertParametersAndType(s);continue}if(i.isInterfaceDeclaration(s)||i.isClassDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertHeritageClauses(s),this.convertMembers(s.members),this.popScope(o);continue}if(i.isTypeAliasDeclaration(s)){const o=this.convertTypeParameters(s.typeParameters);this.convertTypeNode(s.type),this.popScope(o);continue}if(i.isModuleDeclaration(s)){this.convertNamespace(s,t);continue}if(!i.isEnumDeclaration(s)&&!i.isImportDeclaration(s)){if(i.isImportEqualsDeclaration(s)){i.isEntityName(s.moduleReference)&&this.pushReference(this.convertEntityName(s.moduleReference));continue}if(i.isExportDeclaration(s)){if(s.exportClause){if(i.isNamespaceExport(s.exportClause))throw new w(s.exportClause);for(const o of s.exportClause.elements){const a=o.propertyName||o.name;this.pushIdentifierReference(a)}}}else throw new w(s,"namespace child (walking) not supported yet")}}this.popScope()}}function xn({sourceFile:n}){return new Sn(n).transform()}c(xn,"convert");class Sn{static{c(this,"Transformer")}constructor(e){this.sourceFile=e,this.declarations=new Map,this.ast=on(e);for(const t of e.statements)this.convertStatement(t)}transform(){return{ast:this.ast}}pushStatement(e){this.ast.body.push(e)}createDeclaration(e,t){const r={start:e.getFullStart(),end:e.getEnd()};if(!t){const u=new Ke({range:r});return this.pushStatement(u.iife),u}const s=t.getText(),o=new Ke({id:t,range:r}),a=this.declarations.get(s);if(a){a.pushIdentifierReference(t),a.declaration.end=r.end;const u=this.ast.body.findIndex(m=>m==a.declaration);for(let m=u+1;m<this.ast.body.length;m++){const f=this.ast.body[m];f.start=f.end=r.end}}else this.pushStatement(o.declaration),this.declarations.set(s,o);return a||o}convertStatement(e){if(i.isEnumDeclaration(e))return this.convertEnumDeclaration(e);if(i.isFunctionDeclaration(e))return this.convertFunctionDeclaration(e);if(i.isInterfaceDeclaration(e)||i.isClassDeclaration(e))return this.convertClassOrInterfaceDeclaration(e);if(i.isTypeAliasDeclaration(e))return this.convertTypeAliasDeclaration(e);if(i.isVariableStatement(e))return this.convertVariableStatement(e);if(i.isExportDeclaration(e)||i.isExportAssignment(e))return this.convertExportDeclaration(e);if(i.isModuleDeclaration(e))return this.convertNamespaceDeclaration(e);if(e.kind===i.SyntaxKind.NamespaceExportDeclaration)return this.removeStatement(e);if(i.isImportDeclaration(e)||i.isImportEqualsDeclaration(e))return this.convertImportDeclaration(e);throw new w(e)}removeStatement(e){this.pushStatement(b({type:"ExpressionStatement",expression:{type:"Literal",value:"pls remove me"}},e))}convertNamespaceDeclaration(e){if(e.flags&i.NodeFlags.GlobalAugmentation||!i.isIdentifier(e.name)){this.createDeclaration(e).convertNamespace(e,!0);return}const r=this.createDeclaration(e,e.name);r.pushIdentifierReference(e.name),r.convertNamespace(e)}convertEnumDeclaration(e){this.createDeclaration(e,e.name).pushIdentifierReference(e.name)}convertFunctionDeclaration(e){if(!e.name)throw new w(e,"FunctionDeclaration should have a name");const t=this.createDeclaration(e,e.name);t.pushIdentifierReference(e.name),t.convertParametersAndType(e)}convertClassOrInterfaceDeclaration(e){if(!e.name)throw new w(e,"ClassDeclaration / InterfaceDeclaration should have a name");const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertHeritageClauses(e),t.convertMembers(e.members),t.popScope(r)}convertTypeAliasDeclaration(e){const t=this.createDeclaration(e,e.name),r=t.convertTypeParameters(e.typeParameters);t.convertTypeNode(e.type),t.popScope(r)}convertVariableStatement(e){const{declarations:t}=e.declarationList;if(t.length!==1)throw new w(e,"VariableStatement with more than one declaration not yet supported");for(const r of t){if(!i.isIdentifier(r.name))throw new w(e,"VariableDeclaration must have a name");const s=this.createDeclaration(e,r.name);s.convertTypeNode(r.type),r.initializer&&this.trackExpressionReferences(r.initializer,s)}}trackExpressionReferences(e,t){if(i.isIdentifier(e))t.pushIdentifierReference(e);else if(i.isObjectLiteralExpression(e))for(const r of e.properties)i.isShorthandPropertyAssignment(r)?t.pushIdentifierReference(r.name):i.isPropertyAssignment(r)&&this.trackExpressionReferences(r.initializer,t);else if(i.isArrayLiteralExpression(e))for(const r of e.elements)i.isExpression(r)&&this.trackExpressionReferences(r,t);else i.isPropertyAccessExpression(e)&&this.trackExpressionReferences(e.expression,t)}convertExportDeclaration(e){if(i.isExportAssignment(e)){this.pushStatement(b({type:"ExportDefaultDeclaration",declaration:A(e.expression)},e));return}const t=e.moduleSpecifier?A(e.moduleSpecifier):void 0;if(!e.exportClause)this.pushStatement(b({type:"ExportAllDeclaration",source:t,exported:null,attributes:[]},e));else if(i.isNamespaceExport(e.exportClause))this.pushStatement(b({type:"ExportAllDeclaration",source:t,exported:M(e.exportClause.name),attributes:[]},e));else{const r=[];for(const s of e.exportClause.elements)r.push(this.convertExportSpecifier(s));this.pushStatement(b({type:"ExportNamedDeclaration",declaration:null,specifiers:r,source:t,attributes:[]},e))}}convertImportDeclaration(e){if(i.isImportEqualsDeclaration(e)){if(i.isEntityName(e.moduleReference)){const s=this.createDeclaration(e,e.name);s.pushReference(s.convertEntityName(e.moduleReference));return}if(!i.isExternalModuleReference(e.moduleReference))throw new w(e,"ImportEquals should have a literal source.");this.pushStatement(b({type:"ImportDeclaration",specifiers:[{type:"ImportDefaultSpecifier",local:M(e.name)}],source:A(e.moduleReference.expression),attributes:[]},e));return}const t=A(e.moduleSpecifier),r=e.importClause&&e.importClause.namedBindings?this.convertNamedImportBindings(e.importClause.namedBindings):[];e.importClause&&e.importClause.name&&r.push({type:"ImportDefaultSpecifier",local:M(e.importClause.name)}),this.pushStatement(b({type:"ImportDeclaration",specifiers:r,source:t,attributes:[]},e))}convertNamedImportBindings(e){return i.isNamedImports(e)?e.elements.map(t=>{const r=M(t.name),s=t.propertyName?M(t.propertyName):r;return{type:"ImportSpecifier",local:r,imported:s}}):[{type:"ImportNamespaceSpecifier",local:M(e.name)}]}convertExportSpecifier(e){const t=M(e.name);return{type:"ExportSpecifier",exported:t,local:e.propertyName?M(e.propertyName):t}}}class vn{static{c(this,"RelativeModuleDeclarationFixer")}constructor(e,t,r,s){this.sourcemap=r,this.DEBUG=!!process.env.DTS_EXPORTS_FIXER_DEBUG,this.relativeModuleDeclarations=[],this.source=U(e,t.toString()),this.code=t,this.name=s||"./index"}fix(){this.analyze(this.source.statements);for(const e of this.relativeModuleDeclarations){const t=e.getStart(),r=e.getEnd(),s=e.name.kind===i.SyntaxKind.StringLiteral&&"singleQuote"in e.name&&e.name.singleQuote?"'":'"',o=`declare module ${s}${this.name}${s} ${e.body.getText()}`;this.code.overwrite(t,r,o)}return{code:this.code.toString(),map:this.relativeModuleDeclarations.length&&this.sourcemap?this.code.generateMap():null}}analyze(e){for(const t of e)i.isModuleDeclaration(t)&&t.body&&i.isModuleBlock(t.body)&&/^\.\.?\//.test(t.name.text)&&(this.DEBUG&&console.log(`Found relative module declaration: ${t.name.text} in ${this.source.fileName}`),this.relativeModuleDeclarations.push(t))}}function En(n,e,t){const r=G(n),s=G(e.mappings),o=t.split(`
`),a=[];for(let u=0;u<r.length;u+=1){const m=r[u];if(!m||m.length===0){a.push([]);continue}const f=m.find(g=>g.length>=4);if(!f){a.push(m);continue}const[,d,h]=f;if(d!==0||h===void 0||h<0||h>=s.length){a.push(m);continue}const l=s[h];if(!l||l.length===0){a.push(m);continue}const y=f[0],x=f.length>=4?f[3]:0,S=y-(x??0),v=o[u]||"",p=[];for(const g of l){const E=g[0]+S;E<0||E>v.length||(g.length===5?p.push([E,g[1],g[2],g[3],g[4]]):g.length===4?p.push([E,g[1],g[2],g[3]]):p.push([E]))}p.sort((g,E)=>g[0]-E[0]),a.push(p)}return fe(a)}c(En,"hydrateSourcemap");async function Nn(n){const{fileName:e,originalCode:t,inputMapText:r}=n;if(r)try{return JSON.parse(r)}catch{return null}const s=Re.fromSource(t);if(s)return s.toObject();const o=c(async a=>{const u=a.split(/[?#]/)[0],m=N.resolve(N.dirname(e),u);return se.readFile(m,"utf8")},"readMap");try{const a=await Re.fromMapFileSource(t,o);if(a)return a.toObject()}catch{}try{const a=await se.readFile(e+".map","utf8");return JSON.parse(a)}catch{return null}}c(Nn,"loadInputSourcemap");const Tn=c(n=>{const e=new Map,t=new Map,r=new Map;return{name:"dts-transform",buildStart(){e.clear(),t.clear(),r.clear()},options({onLog:s,...o}){return{...o,onLog(a,u,m){a==="warn"&&u.code==="CIRCULAR_DEPENDENCY"||(s?s(a,u,m):m(a,u))},treeshake:{moduleSideEffects:"no-external",propertyReadSideEffects:!0,unknownGlobalSideEffects:!1}}},outputOptions(s){return{...s,chunkFileNames:s.chunkFileNames||"[name]-[hash].d.ts",entryFileNames:s.entryFileNames||"[name].d.ts",format:"es",exports:"named",compact:!1,freeze:!0,interop:"esModule",generatedCode:Object.assign({symbols:!1},s.generatedCode),strict:!1}},transform(s,o,a){const u=Q(o),m=this.getModuleIds(),f=Array.from(m).find(v=>Q(v)===u),d=!!(f&&this.getModuleInfo(f)?.isEntry),h=!!(f&&X.test(f));let l=U(o,s);const y=mn({sourceFile:l,isEntry:d,isJSON:h});e.set(l.fileName,y.typeReferences),t.set(l.fileName,y.fileReferences),s=y.code.toString(),l=U(o,s);const x=xn({sourceFile:l});process.env.DTS_DUMP_AST&&(console.log(o),console.log(s),console.log(JSON.stringify(x.ast.body,void 0,2)));const S=y.code.generateMap({hires:!0,source:o});return n&&_.test(o)&&r.set(o,{fileName:o,originalCode:s,inputMapText:a}),{code:s,ast:x.ast,map:S}},renderChunk(s,o,a){const u=U(o.fileName,s),m=new sn(u),f=new Set,d=new Set;for(const S of Object.keys(o.modules)){for(const v of e.get(S.split("\\").join("/"))||[])f.add(v);for(const v of t.get(S.split("\\").join("/"))||[])if(v.startsWith(".")){const p=N.join(N.dirname(S),v),g=a.file&&N.dirname(a.file)||o.facadeModuleId&&N.dirname(o.facadeModuleId)||".";let E=N.relative(g,p).split("\\").join("/");E[0]!=="."&&(E="./"+E),d.add(E)}else d.add(v)}let h=ze(Array.from(d,S=>`/// <reference path="${S}" />`));h+=ze(Array.from(f,S=>`/// <reference types="${S}" />`)),h+=m.fix(),h||(h+=`
export { };`);const y=new fn(o.fileName,h).fix();return new vn(o.fileName,"magicCode"in y&&y.magicCode?y.magicCode:new W(h),!!a.sourcemap,"./"+N.basename(o.fileName,".d.ts")).fix()},async generateBundle(s,o){if(!s.sourcemap)return;const a=new Map,u=Array.from(r.entries()),m=await Promise.all(u.map(async([h,l])=>({fileName:h,inputMap:await Nn(l)}))),f=c(h=>/^[a-z][a-z0-9+.-]*:\/\//i.test(h),"isUrl");for(const{fileName:h,inputMap:l}of m)if(l&&l.sources){const y=N.dirname(h);let x;l.sourceRoot?x=f(l.sourceRoot)?l.sourceRoot:N.resolve(y,l.sourceRoot):x=y;const S=f(x);a.set(h,{version:l.version??3,sources:l.sources.map(v=>{if(v===null)return null;if(f(v))return v;if(S){const p=x.endsWith("/")?x:x+"/";return new URL(v,p).toString()}return N.isAbsolute(v)?v:N.resolve(x,v)}),mappings:l.mappings,names:l.names})}const d=s.dir||(s.file?N.dirname(s.file):process.cwd());for(const h of Object.values(o)){if(h.type!=="chunk"||!h.map)continue;const l=N.join(d,N.dirname(h.fileName)),y=c(C=>f(C)?C:(N.isAbsolute(C)?N.relative(l,C):C).replaceAll("\\","/"),"toRelativeSourcePath"),x=c(C=>C===null?null:y(C),"toRelativeSourcePathOrNull"),S=new Map;for(const C of h.map.sources){if(!C||f(C))continue;const I=N.resolve(l,C);let F=a.get(I);if(!F&&/\.[cm]?[tj]sx?$/.test(I)&&!I.endsWith(".d.ts")){const D=I.replace(/\.[cm]?[tj]sx?$/,".d.ts");F=a.get(D)}F&&S.set(I,F)}if(S.size===0){if(delete h.map.sourcesContent,h.map.sources.length===0&&h.facadeModuleId){const C=a.get(h.facadeModuleId);if(C&&C.sources.length>0){const I=C.sources.map(x);h.map.sources=I}}Ve(o,h.fileName,{sources:h.map.sources.map(x),mappings:h.map.mappings,names:h.map.names||[]});continue}const p=h.map.sources.length===1&&S.size===1?Array.from(S.values())[0]:null,g=p&&p.sources.length===1;let E,T,O;if(g&&p)E=p.sources.map(x),T=En(h.map.mappings,p,h.code),O=p.names||[];else{const C=Gt(h.map,I=>{const F=N.resolve(l,I),D=S.get(F);return D||null});E=C.sources.map(x),T=typeof C.mappings=="string"?C.mappings:"",O=C.names||[]}h.map.sources=E,delete h.map.sourcesContent,h.map.mappings=T,h.map.names=O,Ve(o,h.fileName,{sources:E,mappings:T,names:O})}}}},"transform");function ze(n){return n.length?n.join(`
`)+`
`:""}c(ze,"writeBlock");function Ve(n,e,t){const r=`${e}.map`,s=n[r];s&&s.type==="asset"&&(s.source=JSON.stringify({version:3,file:N.basename(e),...t}))}c(Ve,"updateSourcemapAsset");const Cn=/\.([cm]ts|[tj]sx?)$/;function ne({entries:n,programs:e,resolvedOptions:t},r,s){const{compilerOptions:o,tsconfig:a}=t;if(!e.length&&_.test(r))return{code:s};const u=n.includes(r),m=e.find(f=>{if(u)return f.getRootFileNames().includes(r);{const d=f.getSourceFile(r);return d&&f.isSourceFileFromExternalLibrary(d)?!1:!!d}});if(m){const f=m.getSourceFile(r);return{code:f?.getFullText(),source:f,program:m}}else if(i.sys.fileExists(r)){if(e.length>0&&_.test(r)&&(t.includeExternal.length>0||t.respectExternal))return{code:s};const f=Zt(r,o,a,t.sourcemap);e.push(f);const d=f.getSourceFile(r);return{code:d?.getFullText(),source:d,program:f}}else return null}c(ne,"getModule");const Je=c((n={})=>{const e={entries:[],programs:[],resolvedOptions:Qt(n)},t=Tn(e.resolvedOptions.sourcemap);return{name:"dts",outputOptions:t.outputOptions,renderChunk:t.renderChunk,generateBundle:t.generateBundle,options(r){let{input:s=[]}=r;if(!Array.isArray(s))s=typeof s=="string"?[s]:Object.values(s);else if(s.length>1){r.input={};for(const o of s){let a=Q(o);N.isAbsolute(o)?a=N.basename(a):a=N.normalize(a),r.input[a]=o}}return e.programs=en(Object.values(s),e.resolvedOptions.compilerOptions,e.resolvedOptions.tsconfig,e.resolvedOptions.sourcemap),t.options.call(this,r)},transform(r,s){if(!Cn.test(s)&&!X.test(s))return null;const o=c(f=>{if(f.program){const d=N.dirname(s);f.program.getSourceFiles().map(l=>l.fileName).filter(l=>l.startsWith(d)).forEach(this.addWatchFile)}},"watchFiles"),a=c(()=>{const f=ne(e,s,r);return f?(o(f),t.transform.call(this,f.code,s)):null},"handleDtsFile"),u=c(()=>{const f=Pe(s),d=ne(e,f,r);return d?(o(d),t.transform.call(this,d.code,f)):null},"treatTsAsDts"),m=c(()=>{const f=ne(e,s,r);if(!f||!f.source||!f.program)return null;o(f);const d=Pe(s);let h,l;const{emitSkipped:y,diagnostics:x}=f.program.emit(f.source,(v,p)=>{v.endsWith(".map")?l=p:h=p},void 0,!0,void 0,!0);if(y){const v=x.filter(p=>p.category===i.DiagnosticCategory.Error);v.length&&(console.error(i.formatDiagnostics(v,Y)),this.error("Failed to compile. Check the logs above."))}if(!h)return null;const S=h.replace(/\n?\/\/# sourceMappingURL=[^\n]+/,"");return t.transform.call(this,S,d,l)},"generateDts");return _.test(s)?a():X.test(s)?m():u()??m()},resolveId(r,s){if(!s){e.entries.push(N.resolve(r));return}s=s.split("\\").join("/");let o=e.resolvedOptions.compilerOptions;if(e.resolvedOptions.tsconfig){const u=r.startsWith(".")?N.resolve(N.dirname(s),r):r;o=Z(u,e.resolvedOptions.compilerOptions,e.resolvedOptions.tsconfig,e.resolvedOptions.sourcemap).compilerOptions}const{resolvedModule:a}=i.resolveModuleName(r,s,o,i.sys);if(a)return a.isExternalLibraryImport&&a.packageId&&e.resolvedOptions.includeExternal.includes(a.packageId.name)?{id:N.resolve(a.resolvedFileName)}:!e.resolvedOptions.respectExternal&&a.isExternalLibraryImport?{id:r,external:!0}:{id:N.resolve(a.resolvedFileName)}}}},"plugin");export{Je as default,Je as dts};
